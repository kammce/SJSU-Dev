<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.11"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>SJSU One API: /var/www/html/SJSU-DEV-Linux/firmware/default/lib/L1_FreeRTOS/include/timers.h File Reference</title>
        <!--<link href="../../tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="../../dynsections.js"></script>
        <link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
        <link href="../../doxygen.css" rel="stylesheet" type="text/css" />
        <link href="../../customdoxygen.css" rel="stylesheet" type="text/css"/>
        <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="../../doxy-boot.js"></script>
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">SJSU One API </a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel " style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part --><!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../files.html"><span>File&#160;List</span></a></li>
      <li><a href="../../globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../dir_d9edf6c004b4a7ff14fe9ae7a92214ee.html">firmware</a></li><li class="navelem"><a class="el" href="../../dir_1cd4931aa993753d363e928640341ec9.html">default</a></li><li class="navelem"><a class="el" href="../../dir_98f6e3228cef689a79f0d5c275585dc1.html">lib</a></li><li class="navelem"><a class="el" href="../../dir_33a561534c50a01e485c5c4ffc1df0f5.html">L1_FreeRTOS</a></li><li class="navelem"><a class="el" href="../../dir_c5a1bdb36512c0b6218fe5cc8b791c5b.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">timers.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="../../db/da4/task_8h_source.html">task.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for timers.h:</div>
<div class="dyncontent">
<div class="center"><img src="../../d1/dcf/timers_8h__incl.png" border="0" usemap="#_2var_2www_2html_2SJSU-DEV-Linux_2firmware_2default_2lib_2L1__FreeRTOS_2include_2timers_8h" alt=""/></div>
<map name="_2var_2www_2html_2SJSU-DEV-Linux_2firmware_2default_2lib_2L1__FreeRTOS_2include_2timers_8h" id="_2var_2www_2html_2SJSU-DEV-Linux_2firmware_2default_2lib_2L1__FreeRTOS_2include_2timers_8h">
<area shape="rect" id="node2" href="../../db/da4/task_8h.html" title="task.h" alt="" coords="61,124,120,151"/>
<area shape="rect" id="node3" href="../../da/d23/list_8h.html" title="list.h" alt="" coords="65,199,116,225"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="../../d2/d54/timers_8h__dep__incl.png" border="0" usemap="#_2var_2www_2html_2SJSU-DEV-Linux_2firmware_2default_2lib_2L1__FreeRTOS_2include_2timers_8hdep" alt=""/></div>
<map name="_2var_2www_2html_2SJSU-DEV-Linux_2firmware_2default_2lib_2L1__FreeRTOS_2include_2timers_8hdep" id="_2var_2www_2html_2SJSU-DEV-Linux_2firmware_2default_2lib_2L1__FreeRTOS_2include_2timers_8hdep">
<area shape="rect" id="node2" href="../../db/d8b/event__groups_8h.html" title="/var/www/html/SJSU\l&#45;DEV&#45;Linux/firmware\l/default/lib/L1_FreeRTOS\l/include/event_groups.h" alt="" coords="5,124,176,195"/>
<area shape="rect" id="node3" href="../../d1/d99/event__groups_8c.html" title="/var/www/html/SJSU\l&#45;DEV&#45;Linux/firmware\l/default/lib/L1_FreeRTOS\l/src/event_groups.c" alt="" coords="67,243,237,313"/>
<area shape="rect" id="node4" href="../../d8/d36/tasks_8c.html" title="/var/www/html/SJSU\l&#45;DEV&#45;Linux/firmware\l/default/lib/L1_FreeRTOS\l/src/tasks.c" alt="" coords="251,124,421,195"/>
<area shape="rect" id="node5" href="../../d0/d80/timers_8c.html" title="/var/www/html/SJSU\l&#45;DEV&#45;Linux/firmware\l/default/lib/L1_FreeRTOS\l/src/timers.c" alt="" coords="445,124,616,195"/>
<area shape="rect" id="node6" href="../../d9/d84/freertos__timer_8hpp.html" title="/var/www/html/SJSU\l&#45;DEV&#45;Linux/firmware\l/default/lib/L3_Utils\l/freertos_timer.hpp" alt="" coords="640,124,787,195"/>
<area shape="rect" id="node7" href="../../d3/d36/freertos__timer_8cpp.html" title="/var/www/html/SJSU\l&#45;DEV&#45;Linux/firmware\l/default/lib/L3_Utils\l/src/freertos_timer.cpp" alt="" coords="637,243,790,313"/>
</map>
</div>
</div>
<p><a href="../../d7/d59/timers_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:aff0b8d2d5d743afef9d52861618139bf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d59/timers_8h.html#aff0b8d2d5d743afef9d52861618139bf">tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR</a>&#160;&#160;&#160;( ( <a class="el" href="../../dc/d35/portmacro_8h.html#a46fb21e00ae0729d7515c0fbf2269796">BaseType_t</a> ) -2 )</td></tr>
<tr class="separator:aff0b8d2d5d743afef9d52861618139bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca42f545424488ce7dfd43c0d70ca610"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d59/timers_8h.html#aca42f545424488ce7dfd43c0d70ca610">tmrCOMMAND_EXECUTE_CALLBACK</a>&#160;&#160;&#160;( ( <a class="el" href="../../dc/d35/portmacro_8h.html#a46fb21e00ae0729d7515c0fbf2269796">BaseType_t</a> ) -1 )</td></tr>
<tr class="separator:aca42f545424488ce7dfd43c0d70ca610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc4f4391b0850b18596974d7618bdfc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d59/timers_8h.html#adcc4f4391b0850b18596974d7618bdfc">tmrCOMMAND_START_DONT_TRACE</a>&#160;&#160;&#160;( ( <a class="el" href="../../dc/d35/portmacro_8h.html#a46fb21e00ae0729d7515c0fbf2269796">BaseType_t</a> ) 0 )</td></tr>
<tr class="separator:adcc4f4391b0850b18596974d7618bdfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc38af63403775cc4ced3995f920343a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d59/timers_8h.html#afc38af63403775cc4ced3995f920343a">tmrCOMMAND_START</a>&#160;&#160;&#160;( ( <a class="el" href="../../dc/d35/portmacro_8h.html#a46fb21e00ae0729d7515c0fbf2269796">BaseType_t</a> ) 1 )</td></tr>
<tr class="separator:afc38af63403775cc4ced3995f920343a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a63f701c021371d186adca7c590e923"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d59/timers_8h.html#a0a63f701c021371d186adca7c590e923">tmrCOMMAND_RESET</a>&#160;&#160;&#160;( ( <a class="el" href="../../dc/d35/portmacro_8h.html#a46fb21e00ae0729d7515c0fbf2269796">BaseType_t</a> ) 2 )</td></tr>
<tr class="separator:a0a63f701c021371d186adca7c590e923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cd6f6a41dcd52d2fc06c350f43516c0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d59/timers_8h.html#a0cd6f6a41dcd52d2fc06c350f43516c0">tmrCOMMAND_STOP</a>&#160;&#160;&#160;( ( <a class="el" href="../../dc/d35/portmacro_8h.html#a46fb21e00ae0729d7515c0fbf2269796">BaseType_t</a> ) 3 )</td></tr>
<tr class="separator:a0cd6f6a41dcd52d2fc06c350f43516c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb27881a1a1118b9cc4d711391c89414"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d59/timers_8h.html#adb27881a1a1118b9cc4d711391c89414">tmrCOMMAND_CHANGE_PERIOD</a>&#160;&#160;&#160;( ( <a class="el" href="../../dc/d35/portmacro_8h.html#a46fb21e00ae0729d7515c0fbf2269796">BaseType_t</a> ) 4 )</td></tr>
<tr class="separator:adb27881a1a1118b9cc4d711391c89414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5586339a9dbc1320153fd96a1c2f33"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d59/timers_8h.html#a5a5586339a9dbc1320153fd96a1c2f33">tmrCOMMAND_DELETE</a>&#160;&#160;&#160;( ( <a class="el" href="../../dc/d35/portmacro_8h.html#a46fb21e00ae0729d7515c0fbf2269796">BaseType_t</a> ) 5 )</td></tr>
<tr class="separator:a5a5586339a9dbc1320153fd96a1c2f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab5e13e40f49f678d62925ab8bc44a1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d59/timers_8h.html#afab5e13e40f49f678d62925ab8bc44a1">tmrFIRST_FROM_ISR_COMMAND</a>&#160;&#160;&#160;( ( <a class="el" href="../../dc/d35/portmacro_8h.html#a46fb21e00ae0729d7515c0fbf2269796">BaseType_t</a> ) 6 )</td></tr>
<tr class="separator:afab5e13e40f49f678d62925ab8bc44a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add053fdcf41607ba790004590c11844f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d59/timers_8h.html#add053fdcf41607ba790004590c11844f">tmrCOMMAND_START_FROM_ISR</a>&#160;&#160;&#160;( ( <a class="el" href="../../dc/d35/portmacro_8h.html#a46fb21e00ae0729d7515c0fbf2269796">BaseType_t</a> ) 6 )</td></tr>
<tr class="separator:add053fdcf41607ba790004590c11844f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d69bd5e47301570a4aa149bd868534a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d59/timers_8h.html#a1d69bd5e47301570a4aa149bd868534a">tmrCOMMAND_RESET_FROM_ISR</a>&#160;&#160;&#160;( ( <a class="el" href="../../dc/d35/portmacro_8h.html#a46fb21e00ae0729d7515c0fbf2269796">BaseType_t</a> ) 7 )</td></tr>
<tr class="separator:a1d69bd5e47301570a4aa149bd868534a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf988b64a5897a1c030da417cc654de"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d59/timers_8h.html#acbf988b64a5897a1c030da417cc654de">tmrCOMMAND_STOP_FROM_ISR</a>&#160;&#160;&#160;( ( <a class="el" href="../../dc/d35/portmacro_8h.html#a46fb21e00ae0729d7515c0fbf2269796">BaseType_t</a> ) 8 )</td></tr>
<tr class="separator:acbf988b64a5897a1c030da417cc654de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab520106084753fbb137ac275ab3ff20b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d59/timers_8h.html#ab520106084753fbb137ac275ab3ff20b">tmrCOMMAND_CHANGE_PERIOD_FROM_ISR</a>&#160;&#160;&#160;( ( <a class="el" href="../../dc/d35/portmacro_8h.html#a46fb21e00ae0729d7515c0fbf2269796">BaseType_t</a> ) 9 )</td></tr>
<tr class="separator:ab520106084753fbb137ac275ab3ff20b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a9b838f48991e852ce05c986b0eeb8c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d59/timers_8h.html#a3a9b838f48991e852ce05c986b0eeb8c">xTimerStart</a>(xTimer,  xTicksToWait)&#160;&#160;&#160;<a class="el" href="../../d7/d59/timers_8h.html#a1ee4da95d99c4e81bfa14c0350fbd594">xTimerGenericCommand</a>( ( xTimer ), <a class="el" href="../../d7/d59/timers_8h.html#afc38af63403775cc4ced3995f920343a">tmrCOMMAND_START</a>, ( <a class="el" href="../../d8/d36/tasks_8c.html#a5fa24e36d5e1eeb57f5b73b72ea048e7">xTaskGetTickCount</a>() ), NULL, ( xTicksToWait ) )</td></tr>
<tr class="separator:a3a9b838f48991e852ce05c986b0eeb8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8327c7fc10aee414cb163b445c5269a4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d59/timers_8h.html#a8327c7fc10aee414cb163b445c5269a4">xTimerStop</a>(xTimer,  xTicksToWait)&#160;&#160;&#160;<a class="el" href="../../d7/d59/timers_8h.html#a1ee4da95d99c4e81bfa14c0350fbd594">xTimerGenericCommand</a>( ( xTimer ), <a class="el" href="../../d7/d59/timers_8h.html#a0cd6f6a41dcd52d2fc06c350f43516c0">tmrCOMMAND_STOP</a>, 0U, NULL, ( xTicksToWait ) )</td></tr>
<tr class="separator:a8327c7fc10aee414cb163b445c5269a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab12eac1c69a3437b8161ce81ff34b2f4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d59/timers_8h.html#ab12eac1c69a3437b8161ce81ff34b2f4">xTimerChangePeriod</a>(xTimer,  xNewPeriod,  xTicksToWait)&#160;&#160;&#160;<a class="el" href="../../d7/d59/timers_8h.html#a1ee4da95d99c4e81bfa14c0350fbd594">xTimerGenericCommand</a>( ( xTimer ), <a class="el" href="../../d7/d59/timers_8h.html#adb27881a1a1118b9cc4d711391c89414">tmrCOMMAND_CHANGE_PERIOD</a>, ( xNewPeriod ), NULL, ( xTicksToWait ) )</td></tr>
<tr class="separator:ab12eac1c69a3437b8161ce81ff34b2f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c8e21f05ebe92e15449addc5d269d10"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d59/timers_8h.html#a8c8e21f05ebe92e15449addc5d269d10">xTimerDelete</a>(xTimer,  xTicksToWait)&#160;&#160;&#160;<a class="el" href="../../d7/d59/timers_8h.html#a1ee4da95d99c4e81bfa14c0350fbd594">xTimerGenericCommand</a>( ( xTimer ), <a class="el" href="../../d7/d59/timers_8h.html#a5a5586339a9dbc1320153fd96a1c2f33">tmrCOMMAND_DELETE</a>, 0U, NULL, ( xTicksToWait ) )</td></tr>
<tr class="separator:a8c8e21f05ebe92e15449addc5d269d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8081b4541b752908dc55df2693e53287"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d59/timers_8h.html#a8081b4541b752908dc55df2693e53287">xTimerReset</a>(xTimer,  xTicksToWait)&#160;&#160;&#160;<a class="el" href="../../d7/d59/timers_8h.html#a1ee4da95d99c4e81bfa14c0350fbd594">xTimerGenericCommand</a>( ( xTimer ), <a class="el" href="../../d7/d59/timers_8h.html#a0a63f701c021371d186adca7c590e923">tmrCOMMAND_RESET</a>, ( <a class="el" href="../../d8/d36/tasks_8c.html#a5fa24e36d5e1eeb57f5b73b72ea048e7">xTaskGetTickCount</a>() ), NULL, ( xTicksToWait ) )</td></tr>
<tr class="separator:a8081b4541b752908dc55df2693e53287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab5809f9679e44a343b8dbb8fb7c67f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d59/timers_8h.html#adab5809f9679e44a343b8dbb8fb7c67f">xTimerStartFromISR</a>(xTimer,  pxHigherPriorityTaskWoken)&#160;&#160;&#160;<a class="el" href="../../d7/d59/timers_8h.html#a1ee4da95d99c4e81bfa14c0350fbd594">xTimerGenericCommand</a>( ( xTimer ), <a class="el" href="../../d7/d59/timers_8h.html#add053fdcf41607ba790004590c11844f">tmrCOMMAND_START_FROM_ISR</a>, ( <a class="el" href="../../d8/d36/tasks_8c.html#ad58fd766b8f438b5703276f585738762">xTaskGetTickCountFromISR</a>() ), ( pxHigherPriorityTaskWoken ), 0U )</td></tr>
<tr class="separator:adab5809f9679e44a343b8dbb8fb7c67f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0f53e7ecfaa881621da83d61072db7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d59/timers_8h.html#aef0f53e7ecfaa881621da83d61072db7">xTimerStopFromISR</a>(xTimer,  pxHigherPriorityTaskWoken)&#160;&#160;&#160;<a class="el" href="../../d7/d59/timers_8h.html#a1ee4da95d99c4e81bfa14c0350fbd594">xTimerGenericCommand</a>( ( xTimer ), <a class="el" href="../../d7/d59/timers_8h.html#acbf988b64a5897a1c030da417cc654de">tmrCOMMAND_STOP_FROM_ISR</a>, 0, ( pxHigherPriorityTaskWoken ), 0U )</td></tr>
<tr class="separator:aef0f53e7ecfaa881621da83d61072db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d89ca6afb6e692e98932b5038c9e14a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d59/timers_8h.html#a6d89ca6afb6e692e98932b5038c9e14a">xTimerChangePeriodFromISR</a>(xTimer,  xNewPeriod,  pxHigherPriorityTaskWoken)&#160;&#160;&#160;<a class="el" href="../../d7/d59/timers_8h.html#a1ee4da95d99c4e81bfa14c0350fbd594">xTimerGenericCommand</a>( ( xTimer ), <a class="el" href="../../d7/d59/timers_8h.html#ab520106084753fbb137ac275ab3ff20b">tmrCOMMAND_CHANGE_PERIOD_FROM_ISR</a>, ( xNewPeriod ), ( pxHigherPriorityTaskWoken ), 0U )</td></tr>
<tr class="separator:a6d89ca6afb6e692e98932b5038c9e14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a448138d0cebf76044f107ca56c842230"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d59/timers_8h.html#a448138d0cebf76044f107ca56c842230">xTimerResetFromISR</a>(xTimer,  pxHigherPriorityTaskWoken)&#160;&#160;&#160;<a class="el" href="../../d7/d59/timers_8h.html#a1ee4da95d99c4e81bfa14c0350fbd594">xTimerGenericCommand</a>( ( xTimer ), <a class="el" href="../../d7/d59/timers_8h.html#a1d69bd5e47301570a4aa149bd868534a">tmrCOMMAND_RESET_FROM_ISR</a>, ( <a class="el" href="../../d8/d36/tasks_8c.html#ad58fd766b8f438b5703276f585738762">xTaskGetTickCountFromISR</a>() ), ( pxHigherPriorityTaskWoken ), 0U )</td></tr>
<tr class="separator:a448138d0cebf76044f107ca56c842230"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aae4bf1dce696ab615d5fd073606fd3cb"><td class="memItemLeft" align="right" valign="top">typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d59/timers_8h.html#aae4bf1dce696ab615d5fd073606fd3cb">TimerHandle_t</a></td></tr>
<tr class="separator:aae4bf1dce696ab615d5fd073606fd3cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf6d1f61ccd4871022ed8ad454c6027"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d59/timers_8h.html#a5cf6d1f61ccd4871022ed8ad454c6027">TimerCallbackFunction_t</a>) (<a class="el" href="../../d7/d59/timers_8h.html#aae4bf1dce696ab615d5fd073606fd3cb">TimerHandle_t</a> xTimer)</td></tr>
<tr class="separator:a5cf6d1f61ccd4871022ed8ad454c6027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6e8e2be58df2be9f9bb808fcdc51622"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d59/timers_8h.html#af6e8e2be58df2be9f9bb808fcdc51622">PendedFunction_t</a>) (void *, uint32_t)</td></tr>
<tr class="separator:af6e8e2be58df2be9f9bb808fcdc51622"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae20907a90360107d72283eb9099685ad"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d59/timers_8h.html#ae20907a90360107d72283eb9099685ad">pvTimerGetTimerID</a> (const <a class="el" href="../../d7/d59/timers_8h.html#aae4bf1dce696ab615d5fd073606fd3cb">TimerHandle_t</a> xTimer) <a class="el" href="../../d5/d31/mpu__wrappers_8h.html#a4785c4f4a8c04b835139dcc2a6682078">PRIVILEGED_FUNCTION</a></td></tr>
<tr class="separator:ae20907a90360107d72283eb9099685ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f06045a953481dd7012d4c7762990cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d59/timers_8h.html#a1f06045a953481dd7012d4c7762990cb">vTimerSetTimerID</a> (<a class="el" href="../../d7/d59/timers_8h.html#aae4bf1dce696ab615d5fd073606fd3cb">TimerHandle_t</a> xTimer, void *pvNewID) <a class="el" href="../../d5/d31/mpu__wrappers_8h.html#a4785c4f4a8c04b835139dcc2a6682078">PRIVILEGED_FUNCTION</a></td></tr>
<tr class="separator:a1f06045a953481dd7012d4c7762990cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cd9b1399fb25203be698f123846dc33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/d35/portmacro_8h.html#a46fb21e00ae0729d7515c0fbf2269796">BaseType_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d59/timers_8h.html#a2cd9b1399fb25203be698f123846dc33">xTimerIsTimerActive</a> (<a class="el" href="../../d7/d59/timers_8h.html#aae4bf1dce696ab615d5fd073606fd3cb">TimerHandle_t</a> xTimer) <a class="el" href="../../d5/d31/mpu__wrappers_8h.html#a4785c4f4a8c04b835139dcc2a6682078">PRIVILEGED_FUNCTION</a></td></tr>
<tr class="separator:a2cd9b1399fb25203be698f123846dc33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2a0d15a1e213493bd898e748d9f7555"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/da4/task_8h.html#ae95f44d4cfeb4a599c6cc258d241cb6b">TaskHandle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d59/timers_8h.html#ad2a0d15a1e213493bd898e748d9f7555">xTimerGetTimerDaemonTaskHandle</a> (void) <a class="el" href="../../d5/d31/mpu__wrappers_8h.html#a4785c4f4a8c04b835139dcc2a6682078">PRIVILEGED_FUNCTION</a></td></tr>
<tr class="separator:ad2a0d15a1e213493bd898e748d9f7555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d9338933037e6feebe6437763fa299"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/d35/portmacro_8h.html#a46fb21e00ae0729d7515c0fbf2269796">BaseType_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d59/timers_8h.html#ae0d9338933037e6feebe6437763fa299">xTimerPendFunctionCallFromISR</a> (<a class="el" href="../../d7/d59/timers_8h.html#af6e8e2be58df2be9f9bb808fcdc51622">PendedFunction_t</a> xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, <a class="el" href="../../dc/d35/portmacro_8h.html#a46fb21e00ae0729d7515c0fbf2269796">BaseType_t</a> *pxHigherPriorityTaskWoken) <a class="el" href="../../d5/d31/mpu__wrappers_8h.html#a4785c4f4a8c04b835139dcc2a6682078">PRIVILEGED_FUNCTION</a></td></tr>
<tr class="separator:ae0d9338933037e6feebe6437763fa299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04e031135bd3276caaedd656d464dc23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/d35/portmacro_8h.html#a46fb21e00ae0729d7515c0fbf2269796">BaseType_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d59/timers_8h.html#a04e031135bd3276caaedd656d464dc23">xTimerPendFunctionCall</a> (<a class="el" href="../../d7/d59/timers_8h.html#af6e8e2be58df2be9f9bb808fcdc51622">PendedFunction_t</a> xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, <a class="el" href="../../dc/d35/portmacro_8h.html#aa69c48c6e902ce54f70886e6573c92a9">TickType_t</a> xTicksToWait) <a class="el" href="../../d5/d31/mpu__wrappers_8h.html#a4785c4f4a8c04b835139dcc2a6682078">PRIVILEGED_FUNCTION</a></td></tr>
<tr class="separator:a04e031135bd3276caaedd656d464dc23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c9186d441d03fc6f97b542f853bd1a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d59/timers_8h.html#a43c9186d441d03fc6f97b542f853bd1a">pcTimerGetName</a> (<a class="el" href="../../d7/d59/timers_8h.html#aae4bf1dce696ab615d5fd073606fd3cb">TimerHandle_t</a> xTimer) <a class="el" href="../../d5/d31/mpu__wrappers_8h.html#a4785c4f4a8c04b835139dcc2a6682078">PRIVILEGED_FUNCTION</a></td></tr>
<tr class="separator:a43c9186d441d03fc6f97b542f853bd1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2735e79e155b2ca2a3809958ebb7431e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/d35/portmacro_8h.html#aa69c48c6e902ce54f70886e6573c92a9">TickType_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d59/timers_8h.html#a2735e79e155b2ca2a3809958ebb7431e">xTimerGetPeriod</a> (<a class="el" href="../../d7/d59/timers_8h.html#aae4bf1dce696ab615d5fd073606fd3cb">TimerHandle_t</a> xTimer) <a class="el" href="../../d5/d31/mpu__wrappers_8h.html#a4785c4f4a8c04b835139dcc2a6682078">PRIVILEGED_FUNCTION</a></td></tr>
<tr class="separator:a2735e79e155b2ca2a3809958ebb7431e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06cdc26759c622eeb575070064e26025"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/d35/portmacro_8h.html#aa69c48c6e902ce54f70886e6573c92a9">TickType_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d59/timers_8h.html#a06cdc26759c622eeb575070064e26025">xTimerGetExpiryTime</a> (<a class="el" href="../../d7/d59/timers_8h.html#aae4bf1dce696ab615d5fd073606fd3cb">TimerHandle_t</a> xTimer) <a class="el" href="../../d5/d31/mpu__wrappers_8h.html#a4785c4f4a8c04b835139dcc2a6682078">PRIVILEGED_FUNCTION</a></td></tr>
<tr class="separator:a06cdc26759c622eeb575070064e26025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af777ab3e9ac04abd5dd21be739fa1321"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/d35/portmacro_8h.html#a46fb21e00ae0729d7515c0fbf2269796">BaseType_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d59/timers_8h.html#af777ab3e9ac04abd5dd21be739fa1321">xTimerCreateTimerTask</a> (void) <a class="el" href="../../d5/d31/mpu__wrappers_8h.html#a4785c4f4a8c04b835139dcc2a6682078">PRIVILEGED_FUNCTION</a></td></tr>
<tr class="separator:af777ab3e9ac04abd5dd21be739fa1321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee4da95d99c4e81bfa14c0350fbd594"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/d35/portmacro_8h.html#a46fb21e00ae0729d7515c0fbf2269796">BaseType_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d59/timers_8h.html#a1ee4da95d99c4e81bfa14c0350fbd594">xTimerGenericCommand</a> (<a class="el" href="../../d7/d59/timers_8h.html#aae4bf1dce696ab615d5fd073606fd3cb">TimerHandle_t</a> xTimer, const <a class="el" href="../../dc/d35/portmacro_8h.html#a46fb21e00ae0729d7515c0fbf2269796">BaseType_t</a> xCommandID, const <a class="el" href="../../dc/d35/portmacro_8h.html#aa69c48c6e902ce54f70886e6573c92a9">TickType_t</a> xOptionalValue, <a class="el" href="../../dc/d35/portmacro_8h.html#a46fb21e00ae0729d7515c0fbf2269796">BaseType_t</a> *const pxHigherPriorityTaskWoken, const <a class="el" href="../../dc/d35/portmacro_8h.html#aa69c48c6e902ce54f70886e6573c92a9">TickType_t</a> xTicksToWait) <a class="el" href="../../d5/d31/mpu__wrappers_8h.html#a4785c4f4a8c04b835139dcc2a6682078">PRIVILEGED_FUNCTION</a></td></tr>
<tr class="separator:a1ee4da95d99c4e81bfa14c0350fbd594"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="adb27881a1a1118b9cc4d711391c89414"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define tmrCOMMAND_CHANGE_PERIOD&#160;&#160;&#160;( ( <a class="el" href="../../dc/d35/portmacro_8h.html#a46fb21e00ae0729d7515c0fbf2269796">BaseType_t</a> ) 4 )</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab520106084753fbb137ac275ab3ff20b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define tmrCOMMAND_CHANGE_PERIOD_FROM_ISR&#160;&#160;&#160;( ( <a class="el" href="../../dc/d35/portmacro_8h.html#a46fb21e00ae0729d7515c0fbf2269796">BaseType_t</a> ) 9 )</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5a5586339a9dbc1320153fd96a1c2f33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define tmrCOMMAND_DELETE&#160;&#160;&#160;( ( <a class="el" href="../../dc/d35/portmacro_8h.html#a46fb21e00ae0729d7515c0fbf2269796">BaseType_t</a> ) 5 )</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aca42f545424488ce7dfd43c0d70ca610"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define tmrCOMMAND_EXECUTE_CALLBACK&#160;&#160;&#160;( ( <a class="el" href="../../dc/d35/portmacro_8h.html#a46fb21e00ae0729d7515c0fbf2269796">BaseType_t</a> ) -1 )</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aff0b8d2d5d743afef9d52861618139bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR&#160;&#160;&#160;( ( <a class="el" href="../../dc/d35/portmacro_8h.html#a46fb21e00ae0729d7515c0fbf2269796">BaseType_t</a> ) -2 )</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0a63f701c021371d186adca7c590e923"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define tmrCOMMAND_RESET&#160;&#160;&#160;( ( <a class="el" href="../../dc/d35/portmacro_8h.html#a46fb21e00ae0729d7515c0fbf2269796">BaseType_t</a> ) 2 )</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1d69bd5e47301570a4aa149bd868534a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define tmrCOMMAND_RESET_FROM_ISR&#160;&#160;&#160;( ( <a class="el" href="../../dc/d35/portmacro_8h.html#a46fb21e00ae0729d7515c0fbf2269796">BaseType_t</a> ) 7 )</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afc38af63403775cc4ced3995f920343a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define tmrCOMMAND_START&#160;&#160;&#160;( ( <a class="el" href="../../dc/d35/portmacro_8h.html#a46fb21e00ae0729d7515c0fbf2269796">BaseType_t</a> ) 1 )</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="adcc4f4391b0850b18596974d7618bdfc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define tmrCOMMAND_START_DONT_TRACE&#160;&#160;&#160;( ( <a class="el" href="../../dc/d35/portmacro_8h.html#a46fb21e00ae0729d7515c0fbf2269796">BaseType_t</a> ) 0 )</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="add053fdcf41607ba790004590c11844f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define tmrCOMMAND_START_FROM_ISR&#160;&#160;&#160;( ( <a class="el" href="../../dc/d35/portmacro_8h.html#a46fb21e00ae0729d7515c0fbf2269796">BaseType_t</a> ) 6 )</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0cd6f6a41dcd52d2fc06c350f43516c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define tmrCOMMAND_STOP&#160;&#160;&#160;( ( <a class="el" href="../../dc/d35/portmacro_8h.html#a46fb21e00ae0729d7515c0fbf2269796">BaseType_t</a> ) 3 )</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="acbf988b64a5897a1c030da417cc654de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define tmrCOMMAND_STOP_FROM_ISR&#160;&#160;&#160;( ( <a class="el" href="../../dc/d35/portmacro_8h.html#a46fb21e00ae0729d7515c0fbf2269796">BaseType_t</a> ) 8 )</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afab5e13e40f49f678d62925ab8bc44a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define tmrFIRST_FROM_ISR_COMMAND&#160;&#160;&#160;( ( <a class="el" href="../../dc/d35/portmacro_8h.html#a46fb21e00ae0729d7515c0fbf2269796">BaseType_t</a> ) 6 )</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab12eac1c69a3437b8161ce81ff34b2f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define xTimerChangePeriod</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">xTimer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">xNewPeriod, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">xTicksToWait&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="../../d7/d59/timers_8h.html#a1ee4da95d99c4e81bfa14c0350fbd594">xTimerGenericCommand</a>( ( xTimer ), <a class="el" href="../../d7/d59/timers_8h.html#adb27881a1a1118b9cc4d711391c89414">tmrCOMMAND_CHANGE_PERIOD</a>, ( xNewPeriod ), NULL, ( xTicksToWait ) )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>BaseType_t xTimerChangePeriod( TimerHandle_t xTimer, TickType_t xNewPeriod, TickType_t xTicksToWait );</p>
<p>Timer functionality is provided by a timer service/daemon task. Many of the public FreeRTOS timer API functions send commands to the timer service task through a queue called the timer command queue. The timer command queue is private to the kernel itself and is not directly accessible to application code. The length of the timer command queue is set by the configTIMER_QUEUE_LENGTH configuration constant.</p>
<p><a class="el" href="../../d7/d59/timers_8h.html#ab12eac1c69a3437b8161ce81ff34b2f4">xTimerChangePeriod()</a> changes the period of a timer that was previously created using the xTimerCreate() API function.</p>
<p><a class="el" href="../../d7/d59/timers_8h.html#ab12eac1c69a3437b8161ce81ff34b2f4">xTimerChangePeriod()</a> can be called to change the period of an active or dormant state timer.</p>
<p>The configUSE_TIMERS configuration constant must be set to 1 for <a class="el" href="../../d7/d59/timers_8h.html#ab12eac1c69a3437b8161ce81ff34b2f4">xTimerChangePeriod()</a> to be available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xTimer</td><td>The handle of the timer that is having its period changed.</td></tr>
    <tr><td class="paramname">xNewPeriod</td><td>The new period for xTimer. Timer periods are specified in tick periods, so the constant portTICK_PERIOD_MS can be used to convert a time that has been specified in milliseconds. For example, if the timer must expire after 100 ticks, then xNewPeriod should be set to 100. Alternatively, if the timer must expire after 500ms, then xNewPeriod can be set to ( 500 / portTICK_PERIOD_MS ) provided configTICK_RATE_HZ is less than or equal to 1000.</td></tr>
    <tr><td class="paramname">xTicksToWait</td><td>Specifies the time, in ticks, that the calling task should be held in the Blocked state to wait for the change period command to be successfully sent to the timer command queue, should the queue already be full when <a class="el" href="../../d7/d59/timers_8h.html#ab12eac1c69a3437b8161ce81ff34b2f4">xTimerChangePeriod()</a> was called. xTicksToWait is ignored if <a class="el" href="../../d7/d59/timers_8h.html#ab12eac1c69a3437b8161ce81ff34b2f4">xTimerChangePeriod()</a> is called before the scheduler is started.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pdFAIL will be returned if the change period command could not be sent to the timer command queue even after xTicksToWait ticks had passed. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant.</dd></dl>
<p>Example usage: </p><pre class="fragment">* // This function assumes xTimer has already been created.  If the timer
* // referenced by xTimer is already active when it is called, then the timer
* // is deleted.  If the timer referenced by xTimer is not active when it is
* // called, then the period of the timer is set to 500ms and the timer is
* // started.
* void vAFunction( TimerHandle_t xTimer )
* {
*     if( xTimerIsTimerActive( xTimer ) != pdFALSE ) // or more simply and equivalently "if( xTimerIsTimerActive( xTimer ) )"
*     {
*         // xTimer is already active - delete it.
*         xTimerDelete( xTimer );
*     }
*     else
*     {
*         // xTimer is not active, change its period to 500ms.  This will also
*         // cause the timer to start.  Block for a maximum of 100 ticks if the
*         // change period command cannot immediately be sent to the timer
*         // command queue.
*         if( xTimerChangePeriod( xTimer, 500 / portTICK_PERIOD_MS, 100 ) == pdPASS )
*         {
*             // The command was successfully sent.
*         }
*         else
*         {
*             // The command could not be sent, even after waiting for 100 ticks
*             // to pass.  Take appropriate action here.
*         }
*     }
* }
* </pre> 
</div>
</div>
<a class="anchor" id="a6d89ca6afb6e692e98932b5038c9e14a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define xTimerChangePeriodFromISR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">xTimer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">xNewPeriod, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pxHigherPriorityTaskWoken&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="../../d7/d59/timers_8h.html#a1ee4da95d99c4e81bfa14c0350fbd594">xTimerGenericCommand</a>( ( xTimer ), <a class="el" href="../../d7/d59/timers_8h.html#ab520106084753fbb137ac275ab3ff20b">tmrCOMMAND_CHANGE_PERIOD_FROM_ISR</a>, ( xNewPeriod ), ( pxHigherPriorityTaskWoken ), 0U )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>BaseType_t xTimerChangePeriodFromISR( TimerHandle_t xTimer, TickType_t xNewPeriod, BaseType_t *pxHigherPriorityTaskWoken );</p>
<p>A version of <a class="el" href="../../d7/d59/timers_8h.html#ab12eac1c69a3437b8161ce81ff34b2f4">xTimerChangePeriod()</a> that can be called from an interrupt service routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xTimer</td><td>The handle of the timer that is having its period changed.</td></tr>
    <tr><td class="paramname">xNewPeriod</td><td>The new period for xTimer. Timer periods are specified in tick periods, so the constant portTICK_PERIOD_MS can be used to convert a time that has been specified in milliseconds. For example, if the timer must expire after 100 ticks, then xNewPeriod should be set to 100. Alternatively, if the timer must expire after 500ms, then xNewPeriod can be set to ( 500 / portTICK_PERIOD_MS ) provided configTICK_RATE_HZ is less than or equal to 1000.</td></tr>
    <tr><td class="paramname">pxHigherPriorityTaskWoken</td><td>The timer service/daemon task spends most of its time in the Blocked state, waiting for messages to arrive on the timer command queue. Calling <a class="el" href="../../d7/d59/timers_8h.html#a6d89ca6afb6e692e98932b5038c9e14a">xTimerChangePeriodFromISR()</a> writes a message to the timer command queue, so has the potential to transition the timer service/ daemon task out of the Blocked state. If calling <a class="el" href="../../d7/d59/timers_8h.html#a6d89ca6afb6e692e98932b5038c9e14a">xTimerChangePeriodFromISR()</a> causes the timer service/daemon task to leave the Blocked state, and the timer service/daemon task has a priority equal to or greater than the currently executing task (the task that was interrupted), then *pxHigherPriorityTaskWoken will get set to pdTRUE internally within the <a class="el" href="../../d7/d59/timers_8h.html#a6d89ca6afb6e692e98932b5038c9e14a">xTimerChangePeriodFromISR()</a> function. If <a class="el" href="../../d7/d59/timers_8h.html#a6d89ca6afb6e692e98932b5038c9e14a">xTimerChangePeriodFromISR()</a> sets this value to pdTRUE then a context switch should be performed before the interrupt exits.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pdFAIL will be returned if the command to change the timers period could not be sent to the timer command queue. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant.</dd></dl>
<p>Example usage: </p><pre class="fragment">* // This scenario assumes xTimer has already been created and started.  When
* // an interrupt occurs, the period of xTimer should be changed to 500ms.
*
* // The interrupt service routine that changes the period of xTimer.
* void vAnExampleInterruptServiceRoutine( void )
* {
* BaseType_t xHigherPriorityTaskWoken = pdFALSE;
*
*     // The interrupt has occurred - change the period of xTimer to 500ms.
*     // xHigherPriorityTaskWoken was set to pdFALSE where it was defined
*     // (within this function).  As this is an interrupt service routine, only
*     // FreeRTOS API functions that end in "FromISR" can be used.
*     if( xTimerChangePeriodFromISR( xTimer, &amp;xHigherPriorityTaskWoken ) != pdPASS )
*     {
*         // The command to change the timers period was not executed
*         // successfully.  Take appropriate action here.
*     }
*
*     // If xHigherPriorityTaskWoken equals pdTRUE, then a context switch
*     // should be performed.  The syntax required to perform a context switch
*     // from inside an ISR varies from port to port, and from compiler to
*     // compiler.  Inspect the demos for the port you are using to find the
*     // actual syntax required.
*     if( xHigherPriorityTaskWoken != pdFALSE )
*     {
*         // Call the interrupt safe yield function here (actual function
*         // depends on the FreeRTOS port being used).
*     }
* }
* </pre> 
</div>
</div>
<a class="anchor" id="a8c8e21f05ebe92e15449addc5d269d10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define xTimerDelete</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">xTimer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">xTicksToWait&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="../../d7/d59/timers_8h.html#a1ee4da95d99c4e81bfa14c0350fbd594">xTimerGenericCommand</a>( ( xTimer ), <a class="el" href="../../d7/d59/timers_8h.html#a5a5586339a9dbc1320153fd96a1c2f33">tmrCOMMAND_DELETE</a>, 0U, NULL, ( xTicksToWait ) )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>BaseType_t <a class="el" href="../../d7/d59/timers_8h.html#a8c8e21f05ebe92e15449addc5d269d10">xTimerDelete( TimerHandle_t xTimer, TickType_t xTicksToWait )</a>;</p>
<p>Timer functionality is provided by a timer service/daemon task. Many of the public FreeRTOS timer API functions send commands to the timer service task through a queue called the timer command queue. The timer command queue is private to the kernel itself and is not directly accessible to application code. The length of the timer command queue is set by the configTIMER_QUEUE_LENGTH configuration constant.</p>
<p><a class="el" href="../../d7/d59/timers_8h.html#a8c8e21f05ebe92e15449addc5d269d10">xTimerDelete()</a> deletes a timer that was previously created using the xTimerCreate() API function.</p>
<p>The configUSE_TIMERS configuration constant must be set to 1 for <a class="el" href="../../d7/d59/timers_8h.html#a8c8e21f05ebe92e15449addc5d269d10">xTimerDelete()</a> to be available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xTimer</td><td>The handle of the timer being deleted.</td></tr>
    <tr><td class="paramname">xTicksToWait</td><td>Specifies the time, in ticks, that the calling task should be held in the Blocked state to wait for the delete command to be successfully sent to the timer command queue, should the queue already be full when <a class="el" href="../../d7/d59/timers_8h.html#a8c8e21f05ebe92e15449addc5d269d10">xTimerDelete()</a> was called. xTicksToWait is ignored if <a class="el" href="../../d7/d59/timers_8h.html#a8c8e21f05ebe92e15449addc5d269d10">xTimerDelete()</a> is called before the scheduler is started.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pdFAIL will be returned if the delete command could not be sent to the timer command queue even after xTicksToWait ticks had passed. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant.</dd></dl>
<p>Example usage:</p>
<p>See the <a class="el" href="../../d7/d59/timers_8h.html#ab12eac1c69a3437b8161ce81ff34b2f4">xTimerChangePeriod()</a> API function example usage scenario. </p>

</div>
</div>
<a class="anchor" id="a8081b4541b752908dc55df2693e53287"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define xTimerReset</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">xTimer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">xTicksToWait&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="../../d7/d59/timers_8h.html#a1ee4da95d99c4e81bfa14c0350fbd594">xTimerGenericCommand</a>( ( xTimer ), <a class="el" href="../../d7/d59/timers_8h.html#a0a63f701c021371d186adca7c590e923">tmrCOMMAND_RESET</a>, ( <a class="el" href="../../d8/d36/tasks_8c.html#a5fa24e36d5e1eeb57f5b73b72ea048e7">xTaskGetTickCount</a>() ), NULL, ( xTicksToWait ) )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>BaseType_t <a class="el" href="../../d7/d59/timers_8h.html#a8081b4541b752908dc55df2693e53287">xTimerReset( TimerHandle_t xTimer, TickType_t xTicksToWait )</a>;</p>
<p>Timer functionality is provided by a timer service/daemon task. Many of the public FreeRTOS timer API functions send commands to the timer service task through a queue called the timer command queue. The timer command queue is private to the kernel itself and is not directly accessible to application code. The length of the timer command queue is set by the configTIMER_QUEUE_LENGTH configuration constant.</p>
<p><a class="el" href="../../d7/d59/timers_8h.html#a8081b4541b752908dc55df2693e53287">xTimerReset()</a> re-starts a timer that was previously created using the xTimerCreate() API function. If the timer had already been started and was already in the active state, then <a class="el" href="../../d7/d59/timers_8h.html#a8081b4541b752908dc55df2693e53287">xTimerReset()</a> will cause the timer to re-evaluate its expiry time so that it is relative to when <a class="el" href="../../d7/d59/timers_8h.html#a8081b4541b752908dc55df2693e53287">xTimerReset()</a> was called. If the timer was in the dormant state then <a class="el" href="../../d7/d59/timers_8h.html#a8081b4541b752908dc55df2693e53287">xTimerReset()</a> has equivalent functionality to the <a class="el" href="../../d7/d59/timers_8h.html#a3a9b838f48991e852ce05c986b0eeb8c">xTimerStart()</a> API function.</p>
<p>Resetting a timer ensures the timer is in the active state. If the timer is not stopped, deleted, or reset in the mean time, the callback function associated with the timer will get called 'n' ticks after <a class="el" href="../../d7/d59/timers_8h.html#a8081b4541b752908dc55df2693e53287">xTimerReset()</a> was called, where 'n' is the timers defined period.</p>
<p>It is valid to call <a class="el" href="../../d7/d59/timers_8h.html#a8081b4541b752908dc55df2693e53287">xTimerReset()</a> before the scheduler has been started, but when this is done the timer will not actually start until the scheduler is started, and the timers expiry time will be relative to when the scheduler is started, not relative to when <a class="el" href="../../d7/d59/timers_8h.html#a8081b4541b752908dc55df2693e53287">xTimerReset()</a> was called.</p>
<p>The configUSE_TIMERS configuration constant must be set to 1 for <a class="el" href="../../d7/d59/timers_8h.html#a8081b4541b752908dc55df2693e53287">xTimerReset()</a> to be available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xTimer</td><td>The handle of the timer being reset/started/restarted.</td></tr>
    <tr><td class="paramname">xTicksToWait</td><td>Specifies the time, in ticks, that the calling task should be held in the Blocked state to wait for the reset command to be successfully sent to the timer command queue, should the queue already be full when <a class="el" href="../../d7/d59/timers_8h.html#a8081b4541b752908dc55df2693e53287">xTimerReset()</a> was called. xTicksToWait is ignored if <a class="el" href="../../d7/d59/timers_8h.html#a8081b4541b752908dc55df2693e53287">xTimerReset()</a> is called before the scheduler is started.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pdFAIL will be returned if the reset command could not be sent to the timer command queue even after xTicksToWait ticks had passed. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system, although the timers expiry time is relative to when <a class="el" href="../../d7/d59/timers_8h.html#a3a9b838f48991e852ce05c986b0eeb8c">xTimerStart()</a> is actually called. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant.</dd></dl>
<p>Example usage: </p><pre class="fragment">* // When a key is pressed, an LCD back-light is switched on.  If 5 seconds pass
* // without a key being pressed, then the LCD back-light is switched off.  In
* // this case, the timer is a one-shot timer.
*
* TimerHandle_t xBacklightTimer = NULL;
*
* // The callback function assigned to the one-shot timer.  In this case the
* // parameter is not used.
* void vBacklightTimerCallback( TimerHandle_t pxTimer )
* {
*     // The timer expired, therefore 5 seconds must have passed since a key
*     // was pressed.  Switch off the LCD back-light.
*     vSetBacklightState( BACKLIGHT_OFF );
* }
*
* // The key press event handler.
* void vKeyPressEventHandler( char cKey )
* {
*     // Ensure the LCD back-light is on, then reset the timer that is
*     // responsible for turning the back-light off after 5 seconds of
*     // key inactivity.  Wait 10 ticks for the command to be successfully sent
*     // if it cannot be sent immediately.
*     vSetBacklightState( BACKLIGHT_ON );
*     if( xTimerReset( xBacklightTimer, 100 ) != pdPASS )
*     {
*         // The reset command was not executed successfully.  Take appropriate
*         // action here.
*     }
*
*     // Perform the rest of the key processing here.
* }
*
* void main( void )
* {
* int32_t x;
*
*     // Create then start the one-shot timer that is responsible for turning
*     // the back-light off if no keys are pressed within a 5 second period.
*     xBacklightTimer = xTimerCreate( "BacklightTimer",           // Just a text name, not used by the kernel.
*                                     ( 5000 / portTICK_PERIOD_MS), // The timer period in ticks.
*                                     pdFALSE,                    // The timer is a one-shot timer.
*                                     0,                          // The id is not used by the callback so can take any value.
*                                     vBacklightTimerCallback     // The callback function that switches the LCD back-light off.
*                                   );
*
*     if( xBacklightTimer == NULL )
*     {
*         // The timer was not created.
*     }
*     else
*     {
*         // Start the timer.  No block time is specified, and even if one was
*         // it would be ignored because the scheduler has not yet been
*         // started.
*         if( xTimerStart( xBacklightTimer, 0 ) != pdPASS )
*         {
*             // The timer could not be set into the Active state.
*         }
*     }
*
*     // ...
*     // Create tasks here.
*     // ...
*
*     // Starting the scheduler will start the timer running as it has already
*     // been set into the active state.
*     vTaskStartScheduler();
*
*     // Should not reach here.
*     for( ;; );
* }
* </pre> 
</div>
</div>
<a class="anchor" id="a448138d0cebf76044f107ca56c842230"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define xTimerResetFromISR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">xTimer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pxHigherPriorityTaskWoken&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="../../d7/d59/timers_8h.html#a1ee4da95d99c4e81bfa14c0350fbd594">xTimerGenericCommand</a>( ( xTimer ), <a class="el" href="../../d7/d59/timers_8h.html#a1d69bd5e47301570a4aa149bd868534a">tmrCOMMAND_RESET_FROM_ISR</a>, ( <a class="el" href="../../d8/d36/tasks_8c.html#ad58fd766b8f438b5703276f585738762">xTaskGetTickCountFromISR</a>() ), ( pxHigherPriorityTaskWoken ), 0U )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>BaseType_t xTimerResetFromISR( TimerHandle_t xTimer, BaseType_t *pxHigherPriorityTaskWoken );</p>
<p>A version of <a class="el" href="../../d7/d59/timers_8h.html#a8081b4541b752908dc55df2693e53287">xTimerReset()</a> that can be called from an interrupt service routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xTimer</td><td>The handle of the timer that is to be started, reset, or restarted.</td></tr>
    <tr><td class="paramname">pxHigherPriorityTaskWoken</td><td>The timer service/daemon task spends most of its time in the Blocked state, waiting for messages to arrive on the timer command queue. Calling <a class="el" href="../../d7/d59/timers_8h.html#a448138d0cebf76044f107ca56c842230">xTimerResetFromISR()</a> writes a message to the timer command queue, so has the potential to transition the timer service/daemon task out of the Blocked state. If calling <a class="el" href="../../d7/d59/timers_8h.html#a448138d0cebf76044f107ca56c842230">xTimerResetFromISR()</a> causes the timer service/daemon task to leave the Blocked state, and the timer service/ daemon task has a priority equal to or greater than the currently executing task (the task that was interrupted), then *pxHigherPriorityTaskWoken will get set to pdTRUE internally within the <a class="el" href="../../d7/d59/timers_8h.html#a448138d0cebf76044f107ca56c842230">xTimerResetFromISR()</a> function. If <a class="el" href="../../d7/d59/timers_8h.html#a448138d0cebf76044f107ca56c842230">xTimerResetFromISR()</a> sets this value to pdTRUE then a context switch should be performed before the interrupt exits.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pdFAIL will be returned if the reset command could not be sent to the timer command queue. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system, although the timers expiry time is relative to when <a class="el" href="../../d7/d59/timers_8h.html#a448138d0cebf76044f107ca56c842230">xTimerResetFromISR()</a> is actually called. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant.</dd></dl>
<p>Example usage: </p><pre class="fragment">* // This scenario assumes xBacklightTimer has already been created.  When a
* // key is pressed, an LCD back-light is switched on.  If 5 seconds pass
* // without a key being pressed, then the LCD back-light is switched off.  In
* // this case, the timer is a one-shot timer, and unlike the example given for
* // the xTimerReset() function, the key press event handler is an interrupt
* // service routine.
*
* // The callback function assigned to the one-shot timer.  In this case the
* // parameter is not used.
* void vBacklightTimerCallback( TimerHandle_t pxTimer )
* {
*     // The timer expired, therefore 5 seconds must have passed since a key
*     // was pressed.  Switch off the LCD back-light.
*     vSetBacklightState( BACKLIGHT_OFF );
* }
*
* // The key press interrupt service routine.
* void vKeyPressEventInterruptHandler( void )
* {
* BaseType_t xHigherPriorityTaskWoken = pdFALSE;
*
*     // Ensure the LCD back-light is on, then reset the timer that is
*     // responsible for turning the back-light off after 5 seconds of
*     // key inactivity.  This is an interrupt service routine so can only
*     // call FreeRTOS API functions that end in "FromISR".
*     vSetBacklightState( BACKLIGHT_ON );
*
*     // xTimerStartFromISR() or xTimerResetFromISR() could be called here
*     // as both cause the timer to re-calculate its expiry time.
*     // xHigherPriorityTaskWoken was initialised to pdFALSE when it was
*     // declared (in this function).
*     if( xTimerResetFromISR( xBacklightTimer, &amp;xHigherPriorityTaskWoken ) != pdPASS )
*     {
*         // The reset command was not executed successfully.  Take appropriate
*         // action here.
*     }
*
*     // Perform the rest of the key processing here.
*
*     // If xHigherPriorityTaskWoken equals pdTRUE, then a context switch
*     // should be performed.  The syntax required to perform a context switch
*     // from inside an ISR varies from port to port, and from compiler to
*     // compiler.  Inspect the demos for the port you are using to find the
*     // actual syntax required.
*     if( xHigherPriorityTaskWoken != pdFALSE )
*     {
*         // Call the interrupt safe yield function here (actual function
*         // depends on the FreeRTOS port being used).
*     }
* }
* </pre> 
</div>
</div>
<a class="anchor" id="a3a9b838f48991e852ce05c986b0eeb8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define xTimerStart</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">xTimer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">xTicksToWait&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="../../d7/d59/timers_8h.html#a1ee4da95d99c4e81bfa14c0350fbd594">xTimerGenericCommand</a>( ( xTimer ), <a class="el" href="../../d7/d59/timers_8h.html#afc38af63403775cc4ced3995f920343a">tmrCOMMAND_START</a>, ( <a class="el" href="../../d8/d36/tasks_8c.html#a5fa24e36d5e1eeb57f5b73b72ea048e7">xTaskGetTickCount</a>() ), NULL, ( xTicksToWait ) )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>BaseType_t <a class="el" href="../../d7/d59/timers_8h.html#a3a9b838f48991e852ce05c986b0eeb8c">xTimerStart( TimerHandle_t xTimer, TickType_t xTicksToWait )</a>;</p>
<p>Timer functionality is provided by a timer service/daemon task. Many of the public FreeRTOS timer API functions send commands to the timer service task through a queue called the timer command queue. The timer command queue is private to the kernel itself and is not directly accessible to application code. The length of the timer command queue is set by the configTIMER_QUEUE_LENGTH configuration constant.</p>
<p><a class="el" href="../../d7/d59/timers_8h.html#a3a9b838f48991e852ce05c986b0eeb8c">xTimerStart()</a> starts a timer that was previously created using the xTimerCreate() API function. If the timer had already been started and was already in the active state, then <a class="el" href="../../d7/d59/timers_8h.html#a3a9b838f48991e852ce05c986b0eeb8c">xTimerStart()</a> has equivalent functionality to the <a class="el" href="../../d7/d59/timers_8h.html#a8081b4541b752908dc55df2693e53287">xTimerReset()</a> API function.</p>
<p>Starting a timer ensures the timer is in the active state. If the timer is not stopped, deleted, or reset in the mean time, the callback function associated with the timer will get called 'n' ticks after <a class="el" href="../../d7/d59/timers_8h.html#a3a9b838f48991e852ce05c986b0eeb8c">xTimerStart()</a> was called, where 'n' is the timers defined period.</p>
<p>It is valid to call <a class="el" href="../../d7/d59/timers_8h.html#a3a9b838f48991e852ce05c986b0eeb8c">xTimerStart()</a> before the scheduler has been started, but when this is done the timer will not actually start until the scheduler is started, and the timers expiry time will be relative to when the scheduler is started, not relative to when <a class="el" href="../../d7/d59/timers_8h.html#a3a9b838f48991e852ce05c986b0eeb8c">xTimerStart()</a> was called.</p>
<p>The configUSE_TIMERS configuration constant must be set to 1 for <a class="el" href="../../d7/d59/timers_8h.html#a3a9b838f48991e852ce05c986b0eeb8c">xTimerStart()</a> to be available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xTimer</td><td>The handle of the timer being started/restarted.</td></tr>
    <tr><td class="paramname">xTicksToWait</td><td>Specifies the time, in ticks, that the calling task should be held in the Blocked state to wait for the start command to be successfully sent to the timer command queue, should the queue already be full when <a class="el" href="../../d7/d59/timers_8h.html#a3a9b838f48991e852ce05c986b0eeb8c">xTimerStart()</a> was called. xTicksToWait is ignored if <a class="el" href="../../d7/d59/timers_8h.html#a3a9b838f48991e852ce05c986b0eeb8c">xTimerStart()</a> is called before the scheduler is started.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pdFAIL will be returned if the start command could not be sent to the timer command queue even after xTicksToWait ticks had passed. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system, although the timers expiry time is relative to when <a class="el" href="../../d7/d59/timers_8h.html#a3a9b838f48991e852ce05c986b0eeb8c">xTimerStart()</a> is actually called. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant.</dd></dl>
<p>Example usage:</p>
<p>See the xTimerCreate() API function example usage scenario. </p>

</div>
</div>
<a class="anchor" id="adab5809f9679e44a343b8dbb8fb7c67f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define xTimerStartFromISR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">xTimer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pxHigherPriorityTaskWoken&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="../../d7/d59/timers_8h.html#a1ee4da95d99c4e81bfa14c0350fbd594">xTimerGenericCommand</a>( ( xTimer ), <a class="el" href="../../d7/d59/timers_8h.html#add053fdcf41607ba790004590c11844f">tmrCOMMAND_START_FROM_ISR</a>, ( <a class="el" href="../../d8/d36/tasks_8c.html#ad58fd766b8f438b5703276f585738762">xTaskGetTickCountFromISR</a>() ), ( pxHigherPriorityTaskWoken ), 0U )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>BaseType_t xTimerStartFromISR( TimerHandle_t xTimer, BaseType_t *pxHigherPriorityTaskWoken );</p>
<p>A version of <a class="el" href="../../d7/d59/timers_8h.html#a3a9b838f48991e852ce05c986b0eeb8c">xTimerStart()</a> that can be called from an interrupt service routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xTimer</td><td>The handle of the timer being started/restarted.</td></tr>
    <tr><td class="paramname">pxHigherPriorityTaskWoken</td><td>The timer service/daemon task spends most of its time in the Blocked state, waiting for messages to arrive on the timer command queue. Calling <a class="el" href="../../d7/d59/timers_8h.html#adab5809f9679e44a343b8dbb8fb7c67f">xTimerStartFromISR()</a> writes a message to the timer command queue, so has the potential to transition the timer service/daemon task out of the Blocked state. If calling <a class="el" href="../../d7/d59/timers_8h.html#adab5809f9679e44a343b8dbb8fb7c67f">xTimerStartFromISR()</a> causes the timer service/daemon task to leave the Blocked state, and the timer service/ daemon task has a priority equal to or greater than the currently executing task (the task that was interrupted), then *pxHigherPriorityTaskWoken will get set to pdTRUE internally within the <a class="el" href="../../d7/d59/timers_8h.html#adab5809f9679e44a343b8dbb8fb7c67f">xTimerStartFromISR()</a> function. If <a class="el" href="../../d7/d59/timers_8h.html#adab5809f9679e44a343b8dbb8fb7c67f">xTimerStartFromISR()</a> sets this value to pdTRUE then a context switch should be performed before the interrupt exits.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pdFAIL will be returned if the start command could not be sent to the timer command queue. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system, although the timers expiry time is relative to when <a class="el" href="../../d7/d59/timers_8h.html#adab5809f9679e44a343b8dbb8fb7c67f">xTimerStartFromISR()</a> is actually called. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant.</dd></dl>
<p>Example usage: </p><pre class="fragment">* // This scenario assumes xBacklightTimer has already been created.  When a
* // key is pressed, an LCD back-light is switched on.  If 5 seconds pass
* // without a key being pressed, then the LCD back-light is switched off.  In
* // this case, the timer is a one-shot timer, and unlike the example given for
* // the xTimerReset() function, the key press event handler is an interrupt
* // service routine.
*
* // The callback function assigned to the one-shot timer.  In this case the
* // parameter is not used.
* void vBacklightTimerCallback( TimerHandle_t pxTimer )
* {
*     // The timer expired, therefore 5 seconds must have passed since a key
*     // was pressed.  Switch off the LCD back-light.
*     vSetBacklightState( BACKLIGHT_OFF );
* }
*
* // The key press interrupt service routine.
* void vKeyPressEventInterruptHandler( void )
* {
* BaseType_t xHigherPriorityTaskWoken = pdFALSE;
*
*     // Ensure the LCD back-light is on, then restart the timer that is
*     // responsible for turning the back-light off after 5 seconds of
*     // key inactivity.  This is an interrupt service routine so can only
*     // call FreeRTOS API functions that end in "FromISR".
*     vSetBacklightState( BACKLIGHT_ON );
*
*     // xTimerStartFromISR() or xTimerResetFromISR() could be called here
*     // as both cause the timer to re-calculate its expiry time.
*     // xHigherPriorityTaskWoken was initialised to pdFALSE when it was
*     // declared (in this function).
*     if( xTimerStartFromISR( xBacklightTimer, &amp;xHigherPriorityTaskWoken ) != pdPASS )
*     {
*         // The start command was not executed successfully.  Take appropriate
*         // action here.
*     }
*
*     // Perform the rest of the key processing here.
*
*     // If xHigherPriorityTaskWoken equals pdTRUE, then a context switch
*     // should be performed.  The syntax required to perform a context switch
*     // from inside an ISR varies from port to port, and from compiler to
*     // compiler.  Inspect the demos for the port you are using to find the
*     // actual syntax required.
*     if( xHigherPriorityTaskWoken != pdFALSE )
*     {
*         // Call the interrupt safe yield function here (actual function
*         // depends on the FreeRTOS port being used).
*     }
* }
* </pre> 
</div>
</div>
<a class="anchor" id="a8327c7fc10aee414cb163b445c5269a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define xTimerStop</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">xTimer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">xTicksToWait&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="../../d7/d59/timers_8h.html#a1ee4da95d99c4e81bfa14c0350fbd594">xTimerGenericCommand</a>( ( xTimer ), <a class="el" href="../../d7/d59/timers_8h.html#a0cd6f6a41dcd52d2fc06c350f43516c0">tmrCOMMAND_STOP</a>, 0U, NULL, ( xTicksToWait ) )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>BaseType_t <a class="el" href="../../d7/d59/timers_8h.html#a8327c7fc10aee414cb163b445c5269a4">xTimerStop( TimerHandle_t xTimer, TickType_t xTicksToWait )</a>;</p>
<p>Timer functionality is provided by a timer service/daemon task. Many of the public FreeRTOS timer API functions send commands to the timer service task through a queue called the timer command queue. The timer command queue is private to the kernel itself and is not directly accessible to application code. The length of the timer command queue is set by the configTIMER_QUEUE_LENGTH configuration constant.</p>
<p><a class="el" href="../../d7/d59/timers_8h.html#a8327c7fc10aee414cb163b445c5269a4">xTimerStop()</a> stops a timer that was previously started using either of the The <a class="el" href="../../d7/d59/timers_8h.html#a3a9b838f48991e852ce05c986b0eeb8c">xTimerStart()</a>, <a class="el" href="../../d7/d59/timers_8h.html#a8081b4541b752908dc55df2693e53287">xTimerReset()</a>, <a class="el" href="../../d7/d59/timers_8h.html#adab5809f9679e44a343b8dbb8fb7c67f">xTimerStartFromISR()</a>, <a class="el" href="../../d7/d59/timers_8h.html#a448138d0cebf76044f107ca56c842230">xTimerResetFromISR()</a>, <a class="el" href="../../d7/d59/timers_8h.html#ab12eac1c69a3437b8161ce81ff34b2f4">xTimerChangePeriod()</a> or <a class="el" href="../../d7/d59/timers_8h.html#a6d89ca6afb6e692e98932b5038c9e14a">xTimerChangePeriodFromISR()</a> API functions.</p>
<p>Stopping a timer ensures the timer is not in the active state.</p>
<p>The configUSE_TIMERS configuration constant must be set to 1 for <a class="el" href="../../d7/d59/timers_8h.html#a8327c7fc10aee414cb163b445c5269a4">xTimerStop()</a> to be available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xTimer</td><td>The handle of the timer being stopped.</td></tr>
    <tr><td class="paramname">xTicksToWait</td><td>Specifies the time, in ticks, that the calling task should be held in the Blocked state to wait for the stop command to be successfully sent to the timer command queue, should the queue already be full when <a class="el" href="../../d7/d59/timers_8h.html#a8327c7fc10aee414cb163b445c5269a4">xTimerStop()</a> was called. xTicksToWait is ignored if <a class="el" href="../../d7/d59/timers_8h.html#a8327c7fc10aee414cb163b445c5269a4">xTimerStop()</a> is called before the scheduler is started.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pdFAIL will be returned if the stop command could not be sent to the timer command queue even after xTicksToWait ticks had passed. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant.</dd></dl>
<p>Example usage:</p>
<p>See the xTimerCreate() API function example usage scenario. </p>

</div>
</div>
<a class="anchor" id="aef0f53e7ecfaa881621da83d61072db7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define xTimerStopFromISR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">xTimer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pxHigherPriorityTaskWoken&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="../../d7/d59/timers_8h.html#a1ee4da95d99c4e81bfa14c0350fbd594">xTimerGenericCommand</a>( ( xTimer ), <a class="el" href="../../d7/d59/timers_8h.html#acbf988b64a5897a1c030da417cc654de">tmrCOMMAND_STOP_FROM_ISR</a>, 0, ( pxHigherPriorityTaskWoken ), 0U )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>BaseType_t xTimerStopFromISR( TimerHandle_t xTimer, BaseType_t *pxHigherPriorityTaskWoken );</p>
<p>A version of <a class="el" href="../../d7/d59/timers_8h.html#a8327c7fc10aee414cb163b445c5269a4">xTimerStop()</a> that can be called from an interrupt service routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xTimer</td><td>The handle of the timer being stopped.</td></tr>
    <tr><td class="paramname">pxHigherPriorityTaskWoken</td><td>The timer service/daemon task spends most of its time in the Blocked state, waiting for messages to arrive on the timer command queue. Calling <a class="el" href="../../d7/d59/timers_8h.html#aef0f53e7ecfaa881621da83d61072db7">xTimerStopFromISR()</a> writes a message to the timer command queue, so has the potential to transition the timer service/daemon task out of the Blocked state. If calling <a class="el" href="../../d7/d59/timers_8h.html#aef0f53e7ecfaa881621da83d61072db7">xTimerStopFromISR()</a> causes the timer service/daemon task to leave the Blocked state, and the timer service/ daemon task has a priority equal to or greater than the currently executing task (the task that was interrupted), then *pxHigherPriorityTaskWoken will get set to pdTRUE internally within the <a class="el" href="../../d7/d59/timers_8h.html#aef0f53e7ecfaa881621da83d61072db7">xTimerStopFromISR()</a> function. If <a class="el" href="../../d7/d59/timers_8h.html#aef0f53e7ecfaa881621da83d61072db7">xTimerStopFromISR()</a> sets this value to pdTRUE then a context switch should be performed before the interrupt exits.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pdFAIL will be returned if the stop command could not be sent to the timer command queue. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant.</dd></dl>
<p>Example usage: </p><pre class="fragment">* // This scenario assumes xTimer has already been created and started.  When
* // an interrupt occurs, the timer should be simply stopped.
*
* // The interrupt service routine that stops the timer.
* void vAnExampleInterruptServiceRoutine( void )
* {
* BaseType_t xHigherPriorityTaskWoken = pdFALSE;
*
*     // The interrupt has occurred - simply stop the timer.
*     // xHigherPriorityTaskWoken was set to pdFALSE where it was defined
*     // (within this function).  As this is an interrupt service routine, only
*     // FreeRTOS API functions that end in "FromISR" can be used.
*     if( xTimerStopFromISR( xTimer, &amp;xHigherPriorityTaskWoken ) != pdPASS )
*     {
*         // The stop command was not executed successfully.  Take appropriate
*         // action here.
*     }
*
*     // If xHigherPriorityTaskWoken equals pdTRUE, then a context switch
*     // should be performed.  The syntax required to perform a context switch
*     // from inside an ISR varies from port to port, and from compiler to
*     // compiler.  Inspect the demos for the port you are using to find the
*     // actual syntax required.
*     if( xHigherPriorityTaskWoken != pdFALSE )
*     {
*         // Call the interrupt safe yield function here (actual function
*         // depends on the FreeRTOS port being used).
*     }
* }
* </pre> 
</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="af6e8e2be58df2be9f9bb808fcdc51622"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* PendedFunction_t) (void *, uint32_t)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5cf6d1f61ccd4871022ed8ad454c6027"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* TimerCallbackFunction_t) (<a class="el" href="../../d7/d59/timers_8h.html#aae4bf1dce696ab615d5fd073606fd3cb">TimerHandle_t</a> xTimer)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aae4bf1dce696ab615d5fd073606fd3cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="../../d7/d59/timers_8h.html#aae4bf1dce696ab615d5fd073606fd3cb">TimerHandle_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type by which software timers are referenced. For example, a call to xTimerCreate() returns an TimerHandle_t variable that can then be used to reference the subject timer in calls to other software timer API functions (for example, <a class="el" href="../../d7/d59/timers_8h.html#a3a9b838f48991e852ce05c986b0eeb8c">xTimerStart()</a>, <a class="el" href="../../d7/d59/timers_8h.html#a8081b4541b752908dc55df2693e53287">xTimerReset()</a>, etc.). </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a43c9186d441d03fc6f97b542f853bd1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* pcTimerGetName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d59/timers_8h.html#aae4bf1dce696ab615d5fd073606fd3cb">TimerHandle_t</a>&#160;</td>
          <td class="paramname"><em>xTimer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>const char * const <a class="el" href="../../d7/d59/timers_8h.html#a43c9186d441d03fc6f97b542f853bd1a">pcTimerGetName( TimerHandle_t xTimer )</a>;</p>
<p>Returns the name that was assigned to a timer when the timer was created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xTimer</td><td>The handle of the timer being queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The name assigned to the timer specified by the xTimer parameter. </dd></dl>

</div>
</div>
<a class="anchor" id="ae20907a90360107d72283eb9099685ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* pvTimerGetTimerID </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d59/timers_8h.html#aae4bf1dce696ab615d5fd073606fd3cb">TimerHandle_t</a>&#160;</td>
          <td class="paramname"><em>xTimer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TimerHandle_t xTimerCreate( const char * const pcTimerName, TickType_t xTimerPeriodInTicks, UBaseType_t uxAutoReload, void * pvTimerID, TimerCallbackFunction_t pxCallbackFunction );</p>
<p>Creates a new software timer instance, and returns a handle by which the created software timer can be referenced.</p>
<p>Internally, within the FreeRTOS implementation, software timers use a block of memory, in which the timer data structure is stored. If a software timer is created using xTimerCreate() then the required memory is automatically dynamically allocated inside the xTimerCreate() function. (see <a href="http://www.freertos.org/a00111.html">http://www.freertos.org/a00111.html</a>). If a software timer is created using xTimerCreateStatic() then the application writer must provide the memory that will get used by the software timer. xTimerCreateStatic() therefore allows a software timer to be created without using any dynamic memory allocation.</p>
<p>Timers are created in the dormant state. The <a class="el" href="../../d7/d59/timers_8h.html#a3a9b838f48991e852ce05c986b0eeb8c">xTimerStart()</a>, <a class="el" href="../../d7/d59/timers_8h.html#a8081b4541b752908dc55df2693e53287">xTimerReset()</a>, <a class="el" href="../../d7/d59/timers_8h.html#adab5809f9679e44a343b8dbb8fb7c67f">xTimerStartFromISR()</a>, <a class="el" href="../../d7/d59/timers_8h.html#a448138d0cebf76044f107ca56c842230">xTimerResetFromISR()</a>, <a class="el" href="../../d7/d59/timers_8h.html#ab12eac1c69a3437b8161ce81ff34b2f4">xTimerChangePeriod()</a> and <a class="el" href="../../d7/d59/timers_8h.html#a6d89ca6afb6e692e98932b5038c9e14a">xTimerChangePeriodFromISR()</a> API functions can all be used to transition a timer into the active state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcTimerName</td><td>A text name that is assigned to the timer. This is done purely to assist debugging. The kernel itself only ever references a timer by its handle, and never by its name.</td></tr>
    <tr><td class="paramname">xTimerPeriodInTicks</td><td>The timer period. The time is defined in tick periods so the constant portTICK_PERIOD_MS can be used to convert a time that has been specified in milliseconds. For example, if the timer must expire after 100 ticks, then xTimerPeriodInTicks should be set to 100. Alternatively, if the timer must expire after 500ms, then xPeriod can be set to ( 500 / portTICK_PERIOD_MS ) provided configTICK_RATE_HZ is less than or equal to 1000.</td></tr>
    <tr><td class="paramname">uxAutoReload</td><td>If uxAutoReload is set to pdTRUE then the timer will expire repeatedly with a frequency set by the xTimerPeriodInTicks parameter. If uxAutoReload is set to pdFALSE then the timer will be a one-shot timer and enter the dormant state after it expires.</td></tr>
    <tr><td class="paramname">pvTimerID</td><td>An identifier that is assigned to the timer being created. Typically this would be used in the timer callback function to identify which timer expired when the same callback function is assigned to more than one timer.</td></tr>
    <tr><td class="paramname">pxCallbackFunction</td><td>The function to call when the timer expires. Callback functions must have the prototype defined by TimerCallbackFunction_t, which is "void vCallbackFunction( TimerHandle_t xTimer );".</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the timer is successfully created then a handle to the newly created timer is returned. If the timer cannot be created (because either there is insufficient FreeRTOS heap remaining to allocate the timer structures, or the timer period was set to 0) then NULL is returned.</dd></dl>
<p>Example usage: </p><pre class="fragment">* #define NUM_TIMERS 5
*
* // An array to hold handles to the created timers.
* TimerHandle_t xTimers[ NUM_TIMERS ];
*
* // An array to hold a count of the number of times each timer expires.
* int32_t lExpireCounters[ NUM_TIMERS ] = { 0 };
*
* // Define a callback function that will be used by multiple timer instances.
* // The callback function does nothing but count the number of times the
* // associated timer expires, and stop the timer once the timer has expired
* // 10 times.
* void vTimerCallback( TimerHandle_t pxTimer )
* {
* int32_t lArrayIndex;
* const int32_t xMaxExpiryCountBeforeStopping = 10;
*
*      // Optionally do something if the pxTimer parameter is NULL.
*      configASSERT( pxTimer );
*
*     // Which timer expired?
*     lArrayIndex = ( int32_t ) pvTimerGetTimerID( pxTimer );
*
*     // Increment the number of times that pxTimer has expired.
*     lExpireCounters[ lArrayIndex ] += 1;
*
*     // If the timer has expired 10 times then stop it from running.
*     if( lExpireCounters[ lArrayIndex ] == xMaxExpiryCountBeforeStopping )
*     {
*         // Do not use a block time if calling a timer API function from a
*         // timer callback function, as doing so could cause a deadlock!
*         xTimerStop( pxTimer, 0 );
*     }
* }
*
* void main( void )
* {
* int32_t x;
*
*     // Create then start some timers.  Starting the timers before the scheduler
*     // has been started means the timers will start running immediately that
*     // the scheduler starts.
*     for( x = 0; x &lt; NUM_TIMERS; x++ )
*     {
*         xTimers[ x ] = xTimerCreate(    "Timer",       // Just a text name, not used by the kernel.
*                                         ( 100 * x ),   // The timer period in ticks.
*                                         pdTRUE,        // The timers will auto-reload themselves when they expire.
*                                         ( void * ) x,  // Assign each timer a unique id equal to its array index.
*                                         vTimerCallback // Each timer calls the same callback when it expires.
*                                     );
*
*         if( xTimers[ x ] == NULL )
*         {
*             // The timer was not created.
*         }
*         else
*         {
*             // Start the timer.  No block time is specified, and even if one was
*             // it would be ignored because the scheduler has not yet been
*             // started.
*             if( xTimerStart( xTimers[ x ], 0 ) != pdPASS )
*             {
*                 // The timer could not be set into the Active state.
*             }
*         }
*     }
*
*     // ...
*     // Create tasks here.
*     // ...
*
*     // Starting the scheduler will start the timers running as they have already
*     // been set into the active state.
*     vTaskStartScheduler();
*
*     // Should not reach here.
*     for( ;; );
* }
* </pre><p> TimerHandle_t xTimerCreateStatic(const char * const pcTimerName, TickType_t xTimerPeriodInTicks, UBaseType_t uxAutoReload, void * pvTimerID, TimerCallbackFunction_t pxCallbackFunction, StaticTimer_t *pxTimerBuffer );</p>
<p>Creates a new software timer instance, and returns a handle by which the created software timer can be referenced.</p>
<p>Internally, within the FreeRTOS implementation, software timers use a block of memory, in which the timer data structure is stored. If a software timer is created using xTimerCreate() then the required memory is automatically dynamically allocated inside the xTimerCreate() function. (see <a href="http://www.freertos.org/a00111.html">http://www.freertos.org/a00111.html</a>). If a software timer is created using xTimerCreateStatic() then the application writer must provide the memory that will get used by the software timer. xTimerCreateStatic() therefore allows a software timer to be created without using any dynamic memory allocation.</p>
<p>Timers are created in the dormant state. The <a class="el" href="../../d7/d59/timers_8h.html#a3a9b838f48991e852ce05c986b0eeb8c">xTimerStart()</a>, <a class="el" href="../../d7/d59/timers_8h.html#a8081b4541b752908dc55df2693e53287">xTimerReset()</a>, <a class="el" href="../../d7/d59/timers_8h.html#adab5809f9679e44a343b8dbb8fb7c67f">xTimerStartFromISR()</a>, <a class="el" href="../../d7/d59/timers_8h.html#a448138d0cebf76044f107ca56c842230">xTimerResetFromISR()</a>, <a class="el" href="../../d7/d59/timers_8h.html#ab12eac1c69a3437b8161ce81ff34b2f4">xTimerChangePeriod()</a> and <a class="el" href="../../d7/d59/timers_8h.html#a6d89ca6afb6e692e98932b5038c9e14a">xTimerChangePeriodFromISR()</a> API functions can all be used to transition a timer into the active state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcTimerName</td><td>A text name that is assigned to the timer. This is done purely to assist debugging. The kernel itself only ever references a timer by its handle, and never by its name.</td></tr>
    <tr><td class="paramname">xTimerPeriodInTicks</td><td>The timer period. The time is defined in tick periods so the constant portTICK_PERIOD_MS can be used to convert a time that has been specified in milliseconds. For example, if the timer must expire after 100 ticks, then xTimerPeriodInTicks should be set to 100. Alternatively, if the timer must expire after 500ms, then xPeriod can be set to ( 500 / portTICK_PERIOD_MS ) provided configTICK_RATE_HZ is less than or equal to 1000.</td></tr>
    <tr><td class="paramname">uxAutoReload</td><td>If uxAutoReload is set to pdTRUE then the timer will expire repeatedly with a frequency set by the xTimerPeriodInTicks parameter. If uxAutoReload is set to pdFALSE then the timer will be a one-shot timer and enter the dormant state after it expires.</td></tr>
    <tr><td class="paramname">pvTimerID</td><td>An identifier that is assigned to the timer being created. Typically this would be used in the timer callback function to identify which timer expired when the same callback function is assigned to more than one timer.</td></tr>
    <tr><td class="paramname">pxCallbackFunction</td><td>The function to call when the timer expires. Callback functions must have the prototype defined by TimerCallbackFunction_t, which is "void vCallbackFunction( TimerHandle_t xTimer );".</td></tr>
    <tr><td class="paramname">pxTimerBuffer</td><td>Must point to a variable of type StaticTimer_t, which will be then be used to hold the software timer's data structures, removing the need for the memory to be allocated dynamically.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the timer is created then a handle to the created timer is returned. If pxTimerBuffer was NULL then NULL is returned.</dd></dl>
<p>Example usage: </p><pre class="fragment">*
* // The buffer used to hold the software timer's data structure.
* static StaticTimer_t xTimerBuffer;
*
* // A variable that will be incremented by the software timer's callback
* // function.
* UBaseType_t uxVariableToIncrement = 0;
*
* // A software timer callback function that increments a variable passed to
* // it when the software timer was created.  After the 5th increment the
* // callback function stops the software timer.
* static void prvTimerCallback( TimerHandle_t xExpiredTimer )
* {
* UBaseType_t *puxVariableToIncrement;
* BaseType_t xReturned;
*
*     // Obtain the address of the variable to increment from the timer ID.
*     puxVariableToIncrement = ( UBaseType_t * ) pvTimerGetTimerID( xExpiredTimer );
*
*     // Increment the variable to show the timer callback has executed.
*     ( *puxVariableToIncrement )++;
*
*     // If this callback has executed the required number of times, stop the
*     // timer.
*     if( *puxVariableToIncrement == 5 )
*     {
*         // This is called from a timer callback so must not block.
*         xTimerStop( xExpiredTimer, staticDONT_BLOCK );
*     }
* }
*
*
* void main( void )
* {
*     // Create the software time.  xTimerCreateStatic() has an extra parameter
*     // than the normal xTimerCreate() API function.  The parameter is a pointer
*     // to the StaticTimer_t structure that will hold the software timer
*     // structure.  If the parameter is passed as NULL then the structure will be
*     // allocated dynamically, just as if xTimerCreate() had been called.
*     xTimer = xTimerCreateStatic( "T1",             // Text name for the task.  Helps debugging only.  Not used by FreeRTOS.
*                                  xTimerPeriod,     // The period of the timer in ticks.
*                                  pdTRUE,           // This is an auto-reload timer.
*                                  ( void * ) &amp;uxVariableToIncrement,    // A variable incremented by the software timer's callback function
*                                  prvTimerCallback, // The function to execute when the timer expires.
*                                  &amp;xTimerBuffer );  // The buffer that will hold the software timer structure.
*
*     // The scheduler has not started yet so a block time is not used.
*     xReturned = xTimerStart( xTimer, 0 );
*
*     // ...
*     // Create tasks here.
*     // ...
*
*     // Starting the scheduler will start the timers running as they have already
*     // been set into the active state.
*     vTaskStartScheduler();
*
*     // Should not reach here.
*     for( ;; );
* }
* </pre><p> void *pvTimerGetTimerID( TimerHandle_t xTimer );</p>
<p>Returns the ID assigned to the timer.</p>
<p>IDs are assigned to timers using the pvTimerID parameter of the call to xTimerCreated() that was used to create the timer, and by calling the <a class="el" href="../../d7/d59/timers_8h.html#a1f06045a953481dd7012d4c7762990cb">vTimerSetTimerID()</a> API function.</p>
<p>If the same callback function is assigned to multiple timers then the timer ID can be used as time specific (timer local) storage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xTimer</td><td>The timer being queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The ID assigned to the timer being queried.</dd></dl>
<p>Example usage:</p>
<p>See the xTimerCreate() API function example usage scenario. </p>

</div>
</div>
<a class="anchor" id="a1f06045a953481dd7012d4c7762990cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vTimerSetTimerID </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d59/timers_8h.html#aae4bf1dce696ab615d5fd073606fd3cb">TimerHandle_t</a>&#160;</td>
          <td class="paramname"><em>xTimer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvNewID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>void <a class="el" href="../../d7/d59/timers_8h.html#a1f06045a953481dd7012d4c7762990cb">vTimerSetTimerID( TimerHandle_t xTimer, void *pvNewID )</a>;</p>
<p>Sets the ID assigned to the timer.</p>
<p>IDs are assigned to timers using the pvTimerID parameter of the call to xTimerCreated() that was used to create the timer.</p>
<p>If the same callback function is assigned to multiple timers then the timer ID can be used as time specific (timer local) storage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xTimer</td><td>The timer being updated.</td></tr>
    <tr><td class="paramname">pvNewID</td><td>The ID to assign to the timer.</td></tr>
  </table>
  </dd>
</dl>
<p>Example usage:</p>
<p>See the xTimerCreate() API function example usage scenario. </p>

</div>
</div>
<a class="anchor" id="af777ab3e9ac04abd5dd21be739fa1321"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d35/portmacro_8h.html#a46fb21e00ae0729d7515c0fbf2269796">BaseType_t</a> xTimerCreateTimerTask </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1ee4da95d99c4e81bfa14c0350fbd594"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d35/portmacro_8h.html#a46fb21e00ae0729d7515c0fbf2269796">BaseType_t</a> xTimerGenericCommand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d59/timers_8h.html#aae4bf1dce696ab615d5fd073606fd3cb">TimerHandle_t</a>&#160;</td>
          <td class="paramname"><em>xTimer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/d35/portmacro_8h.html#a46fb21e00ae0729d7515c0fbf2269796">BaseType_t</a>&#160;</td>
          <td class="paramname"><em>xCommandID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/d35/portmacro_8h.html#aa69c48c6e902ce54f70886e6573c92a9">TickType_t</a>&#160;</td>
          <td class="paramname"><em>xOptionalValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d35/portmacro_8h.html#a46fb21e00ae0729d7515c0fbf2269796">BaseType_t</a> *const&#160;</td>
          <td class="paramname"><em>pxHigherPriorityTaskWoken</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/d35/portmacro_8h.html#aa69c48c6e902ce54f70886e6573c92a9">TickType_t</a>&#160;</td>
          <td class="paramname"><em>xTicksToWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a06cdc26759c622eeb575070064e26025"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d35/portmacro_8h.html#aa69c48c6e902ce54f70886e6573c92a9">TickType_t</a> xTimerGetExpiryTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d59/timers_8h.html#aae4bf1dce696ab615d5fd073606fd3cb">TimerHandle_t</a>&#160;</td>
          <td class="paramname"><em>xTimer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TickType_t <a class="el" href="../../d7/d59/timers_8h.html#a06cdc26759c622eeb575070064e26025">xTimerGetExpiryTime( TimerHandle_t xTimer )</a>;</p>
<p>Returns the time in ticks at which the timer will expire. If this is less than the current tick count then the expiry time has overflowed from the current time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xTimer</td><td>The handle of the timer being queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the timer is running then the time in ticks at which the timer will next expire is returned. If the timer is not running then the return value is undefined. </dd></dl>

</div>
</div>
<a class="anchor" id="a2735e79e155b2ca2a3809958ebb7431e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d35/portmacro_8h.html#aa69c48c6e902ce54f70886e6573c92a9">TickType_t</a> xTimerGetPeriod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d59/timers_8h.html#aae4bf1dce696ab615d5fd073606fd3cb">TimerHandle_t</a>&#160;</td>
          <td class="paramname"><em>xTimer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TickType_t <a class="el" href="../../d7/d59/timers_8h.html#a2735e79e155b2ca2a3809958ebb7431e">xTimerGetPeriod( TimerHandle_t xTimer )</a>;</p>
<p>Returns the period of a timer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xTimer</td><td>The handle of the timer being queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The period of the timer in ticks. </dd></dl>

</div>
</div>
<a class="anchor" id="ad2a0d15a1e213493bd898e748d9f7555"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/da4/task_8h.html#ae95f44d4cfeb4a599c6cc258d241cb6b">TaskHandle_t</a> xTimerGetTimerDaemonTaskHandle </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TaskHandle_t <a class="el" href="../../d7/d59/timers_8h.html#ad2a0d15a1e213493bd898e748d9f7555">xTimerGetTimerDaemonTaskHandle( void )</a>;</p>
<p>Simply returns the handle of the timer service/daemon task. It it not valid to call <a class="el" href="../../d7/d59/timers_8h.html#ad2a0d15a1e213493bd898e748d9f7555">xTimerGetTimerDaemonTaskHandle()</a> before the scheduler has been started. </p>

</div>
</div>
<a class="anchor" id="a2cd9b1399fb25203be698f123846dc33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d35/portmacro_8h.html#a46fb21e00ae0729d7515c0fbf2269796">BaseType_t</a> xTimerIsTimerActive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d59/timers_8h.html#aae4bf1dce696ab615d5fd073606fd3cb">TimerHandle_t</a>&#160;</td>
          <td class="paramname"><em>xTimer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>BaseType_t <a class="el" href="../../d7/d59/timers_8h.html#a2cd9b1399fb25203be698f123846dc33">xTimerIsTimerActive( TimerHandle_t xTimer )</a>;</p>
<p>Queries a timer to see if it is active or dormant.</p>
<p>A timer will be dormant if: 1) It has been created but not started, or 2) It is an expired one-shot timer that has not been restarted.</p>
<p>Timers are created in the dormant state. The <a class="el" href="../../d7/d59/timers_8h.html#a3a9b838f48991e852ce05c986b0eeb8c">xTimerStart()</a>, <a class="el" href="../../d7/d59/timers_8h.html#a8081b4541b752908dc55df2693e53287">xTimerReset()</a>, <a class="el" href="../../d7/d59/timers_8h.html#adab5809f9679e44a343b8dbb8fb7c67f">xTimerStartFromISR()</a>, <a class="el" href="../../d7/d59/timers_8h.html#a448138d0cebf76044f107ca56c842230">xTimerResetFromISR()</a>, <a class="el" href="../../d7/d59/timers_8h.html#ab12eac1c69a3437b8161ce81ff34b2f4">xTimerChangePeriod()</a> and <a class="el" href="../../d7/d59/timers_8h.html#a6d89ca6afb6e692e98932b5038c9e14a">xTimerChangePeriodFromISR()</a> API functions can all be used to transition a timer into the active state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xTimer</td><td>The timer being queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pdFALSE will be returned if the timer is dormant. A value other than pdFALSE will be returned if the timer is active.</dd></dl>
<p>Example usage: </p><pre class="fragment">* // This function assumes xTimer has already been created.
* void vAFunction( TimerHandle_t xTimer )
* {
*     if( xTimerIsTimerActive( xTimer ) != pdFALSE ) // or more simply and equivalently "if( xTimerIsTimerActive( xTimer ) )"
*     {
*         // xTimer is active, do something.
*     }
*     else
*     {
*         // xTimer is not active, do something else.
*     }
* }
* </pre> 
</div>
</div>
<a class="anchor" id="a04e031135bd3276caaedd656d464dc23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d35/portmacro_8h.html#a46fb21e00ae0729d7515c0fbf2269796">BaseType_t</a> xTimerPendFunctionCall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d59/timers_8h.html#af6e8e2be58df2be9f9bb808fcdc51622">PendedFunction_t</a>&#160;</td>
          <td class="paramname"><em>xFunctionToPend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvParameter1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ulParameter2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d35/portmacro_8h.html#aa69c48c6e902ce54f70886e6573c92a9">TickType_t</a>&#160;</td>
          <td class="paramname"><em>xTicksToWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>BaseType_t xTimerPendFunctionCall( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, TickType_t xTicksToWait );</p>
<p>Used to defer the execution of a function to the RTOS daemon task (the timer service task, hence this function is implemented in timers.c and is prefixed with 'Timer').</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xFunctionToPend</td><td>The function to execute from the timer service/ daemon task. The function must conform to the PendedFunction_t prototype.</td></tr>
    <tr><td class="paramname">pvParameter1</td><td>The value of the callback function's first parameter. The parameter has a void * type to allow it to be used to pass any type. For example, unsigned longs can be cast to a void *, or the void * can be used to point to a structure.</td></tr>
    <tr><td class="paramname">ulParameter2</td><td>The value of the callback function's second parameter.</td></tr>
    <tr><td class="paramname">xTicksToWait</td><td>Calling this function will result in a message being sent to the timer daemon task on a queue. xTicksToWait is the amount of time the calling task should remain in the Blocked state (so not using any processing time) for space to become available on the timer queue if the queue is found to be full.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pdPASS is returned if the message was successfully sent to the timer daemon task, otherwise pdFALSE is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="ae0d9338933037e6feebe6437763fa299"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d35/portmacro_8h.html#a46fb21e00ae0729d7515c0fbf2269796">BaseType_t</a> xTimerPendFunctionCallFromISR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d59/timers_8h.html#af6e8e2be58df2be9f9bb808fcdc51622">PendedFunction_t</a>&#160;</td>
          <td class="paramname"><em>xFunctionToPend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvParameter1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ulParameter2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d35/portmacro_8h.html#a46fb21e00ae0729d7515c0fbf2269796">BaseType_t</a> *&#160;</td>
          <td class="paramname"><em>pxHigherPriorityTaskWoken</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>BaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, BaseType_t *pxHigherPriorityTaskWoken );</p>
<p>Used from application interrupt service routines to defer the execution of a function to the RTOS daemon task (the timer service task, hence this function is implemented in timers.c and is prefixed with 'Timer').</p>
<p>Ideally an interrupt service routine (ISR) is kept as short as possible, but sometimes an ISR either has a lot of processing to do, or needs to perform processing that is not deterministic. In these cases <a class="el" href="../../d7/d59/timers_8h.html#ae0d9338933037e6feebe6437763fa299">xTimerPendFunctionCallFromISR()</a> can be used to defer processing of a function to the RTOS daemon task.</p>
<p>A mechanism is provided that allows the interrupt to return directly to the task that will subsequently execute the pended callback function. This allows the callback function to execute contiguously in time with the interrupt - just as if the callback had executed in the interrupt itself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xFunctionToPend</td><td>The function to execute from the timer service/ daemon task. The function must conform to the PendedFunction_t prototype.</td></tr>
    <tr><td class="paramname">pvParameter1</td><td>The value of the callback function's first parameter. The parameter has a void * type to allow it to be used to pass any type. For example, unsigned longs can be cast to a void *, or the void * can be used to point to a structure.</td></tr>
    <tr><td class="paramname">ulParameter2</td><td>The value of the callback function's second parameter.</td></tr>
    <tr><td class="paramname">pxHigherPriorityTaskWoken</td><td>As mentioned above, calling this function will result in a message being sent to the timer daemon task. If the priority of the timer daemon task (which is set using configTIMER_TASK_PRIORITY in <a class="el" href="../../db/dc7/FreeRTOSConfig_8h.html">FreeRTOSConfig.h</a>) is higher than the priority of the currently running task (the task the interrupt interrupted) then *pxHigherPriorityTaskWoken will be set to pdTRUE within <a class="el" href="../../d7/d59/timers_8h.html#ae0d9338933037e6feebe6437763fa299">xTimerPendFunctionCallFromISR()</a>, indicating that a context switch should be requested before the interrupt exits. For that reason *pxHigherPriorityTaskWoken must be initialised to pdFALSE. See the example code below.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pdPASS is returned if the message was successfully sent to the timer daemon task, otherwise pdFALSE is returned.</dd></dl>
<p>Example usage: </p><pre class="fragment">*
*   // The callback function that will execute in the context of the daemon task.
*  // Note callback functions must all use this same prototype.
*  void vProcessInterface( void *pvParameter1, uint32_t ulParameter2 )
*   {
*       BaseType_t xInterfaceToService;
*
*       // The interface that requires servicing is passed in the second
*      // parameter.  The first parameter is not used in this case.
*       xInterfaceToService = ( BaseType_t ) ulParameter2;
*
*       // ...Perform the processing here...
*   }
*
*   // An ISR that receives data packets from multiple interfaces
*  void vAnISR( void )
*   {
*       BaseType_t xInterfaceToService, xHigherPriorityTaskWoken;
*
*       // Query the hardware to determine which interface needs processing.
*       xInterfaceToService = prvCheckInterfaces();
*
*      // The actual processing is to be deferred to a task.  Request the
*      // vProcessInterface() callback function is executed, passing in the
*       // number of the interface that needs processing.  The interface to
*       // service is passed in the second parameter.  The first parameter is
*       // not used in this case.
*       xHigherPriorityTaskWoken = pdFALSE;
*       xTimerPendFunctionCallFromISR( vProcessInterface, NULL, ( uint32_t ) xInterfaceToService, &amp;xHigherPriorityTaskWoken );
*
*       // If xHigherPriorityTaskWoken is now set to pdTRUE then a context
*       // switch should be requested.  The macro used is port specific and will
*       // be either portYIELD_FROM_ISR() or portEND_SWITCHING_ISR() - refer to
*       // the documentation page for the port being used.
*       portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
*
*   }
* </pre> 
</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
