\hypertarget{group__xTaskNotifyWait}{}\section{x\+Task\+Notify\+Wait}
\label{group__xTaskNotifyWait}\index{x\+Task\+Notify\+Wait@{x\+Task\+Notify\+Wait}}
task. h 
\begin{DoxyPre}BaseType\_t \hyperlink{task_8h_a0475fcda9718f403521c270a7270ff93}{xTaskNotifyWait( uint32\_t ulBitsToClearOnEntry, uint32\_t ulBitsToClearOnExit, uint32\_t *pulNotificationValue, TickType\_t xTicksToWait )};\end{DoxyPre}


config\+U\+S\+E\+\_\+\+T\+A\+S\+K\+\_\+\+N\+O\+T\+I\+F\+I\+C\+A\+T\+I\+O\+NS must be undefined or defined as 1 for this function to be available.

When config\+U\+S\+E\+\_\+\+T\+A\+S\+K\+\_\+\+N\+O\+T\+I\+F\+I\+C\+A\+T\+I\+O\+NS is set to one each task has its own private \char`\"{}notification value\char`\"{}, which is a 32-\/bit unsigned integer (uint32\+\_\+t).

Events can be sent to a task using an intermediary object. Examples of such objects are queues, semaphores, mutexes and event groups. Task notifications are a method of sending an event directly to a task without the need for such an intermediary object.

A notification sent to a task can optionally perform an action, such as update, overwrite or increment the task\textquotesingle{}s notification value. In that way task notifications can be used to send data to a task, or be used as light weight and fast binary or counting semaphores.

A notification sent to a task will remain pending until it is cleared by the task calling \hyperlink{task_8h_a0475fcda9718f403521c270a7270ff93}{x\+Task\+Notify\+Wait()} or \hyperlink{task_8h_a66540bef602522a01a519f776e4c07d8}{ul\+Task\+Notify\+Take()}. If the task was already in the Blocked state to wait for a notification when the notification arrives then the task will automatically be removed from the Blocked state (unblocked) and the notification cleared.

A task can use \hyperlink{task_8h_a0475fcda9718f403521c270a7270ff93}{x\+Task\+Notify\+Wait()} to \mbox{[}optionally\mbox{]} block to wait for a notification to be pending, or \hyperlink{task_8h_a66540bef602522a01a519f776e4c07d8}{ul\+Task\+Notify\+Take()} to \mbox{[}optionally\mbox{]} block to wait for its notification value to have a non-\/zero value. The task does not consume any C\+PU time while it is in the Blocked state.

See \href{http://www.FreeRTOS.org/RTOS-task-notifications.html}{\tt http\+://www.\+Free\+R\+T\+O\+S.\+org/\+R\+T\+O\+S-\/task-\/notifications.\+html} for details.


\begin{DoxyParams}{Parameters}
{\em ul\+Bits\+To\+Clear\+On\+Entry} & Bits that are set in ul\+Bits\+To\+Clear\+On\+Entry value will be cleared in the calling task\textquotesingle{}s notification value before the task checks to see if any notifications are pending, and optionally blocks if no notifications are pending. Setting ul\+Bits\+To\+Clear\+On\+Entry to U\+L\+O\+N\+G\+\_\+\+M\+AX (if limits.\+h is included) or 0xffffffff\+UL (if limits.\+h is not included) will have the effect of resetting the task\textquotesingle{}s notification value to 0. Setting ul\+Bits\+To\+Clear\+On\+Entry to 0 will leave the task\textquotesingle{}s notification value unchanged.\\
\hline
{\em ul\+Bits\+To\+Clear\+On\+Exit} & If a notification is pending or received before the calling task exits the \hyperlink{task_8h_a0475fcda9718f403521c270a7270ff93}{x\+Task\+Notify\+Wait()} function then the task\textquotesingle{}s notification value (see the \hyperlink{task_8h_a0d2d54fb8a64011dfbb54983e4ed06bd}{x\+Task\+Notify()} A\+PI function) is passed out using the pul\+Notification\+Value parameter. Then any bits that are set in ul\+Bits\+To\+Clear\+On\+Exit will be cleared in the task\textquotesingle{}s notification value (note $\ast$pul\+Notification\+Value is set before any bits are cleared). Setting ul\+Bits\+To\+Clear\+On\+Exit to U\+L\+O\+N\+G\+\_\+\+M\+AX (if limits.\+h is included) or 0xffffffff\+UL (if limits.\+h is not included) will have the effect of resetting the task\textquotesingle{}s notification value to 0 before the function exits. Setting ul\+Bits\+To\+Clear\+On\+Exit to 0 will leave the task\textquotesingle{}s notification value unchanged when the function exits (in which case the value passed out in pul\+Notification\+Value will match the task\textquotesingle{}s notification value).\\
\hline
{\em pul\+Notification\+Value} & Used to pass the task\textquotesingle{}s notification value out of the function. Note the value passed out will not be effected by the clearing of any bits caused by ul\+Bits\+To\+Clear\+On\+Exit being non-\/zero.\\
\hline
{\em x\+Ticks\+To\+Wait} & The maximum amount of time that the task should wait in the Blocked state for a notification to be received, should a notification not already be pending when \hyperlink{task_8h_a0475fcda9718f403521c270a7270ff93}{x\+Task\+Notify\+Wait()} was called. The task will not consume any processing time while it is in the Blocked state. This is specified in kernel ticks, the macro pd\+M\+S\+\_\+\+T\+O\+\_\+\+T\+I\+C\+S\+K( value\+\_\+in\+\_\+ms ) can be used to convert a time specified in milliseconds to a time specified in ticks.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
If a notification was received (including notifications that were already pending when x\+Task\+Notify\+Wait was called) then pd\+P\+A\+SS is returned. Otherwise pd\+F\+A\+IL is returned.
\end{DoxyReturn}
task. h 
\begin{DoxyPre}void \hyperlink{task_8h_a4a4bcf98ad282a596e13f3f30582a11b}{vTaskNotifyGiveFromISR( TaskHandle\_t xTaskHandle, BaseType\_t *pxHigherPriorityTaskWoken )};\end{DoxyPre}



\begin{DoxyPre}configUSE\_TASK\_NOTIFICATIONS must be undefined or defined as 1 for this macro
to be available.\end{DoxyPre}



\begin{DoxyPre}When configUSE\_TASK\_NOTIFICATIONS is set to one each task has its own private
"notification value", which is a 32-bit unsigned integer (uint32\_t).\end{DoxyPre}



\begin{DoxyPre}A version of \hyperlink{task_8h_ac60cbd05577a3e4f3c3587dd9b213930}{xTaskNotifyGive()} that can be called from an interrupt service
routine (ISR).\end{DoxyPre}



\begin{DoxyPre}Events can be sent to a task using an intermediary object.  Examples of such
objects are queues, semaphores, mutexes and event groups.  Task notifications
are a method of sending an event directly to a task without the need for such
an intermediary object.\end{DoxyPre}



\begin{DoxyPre}A notification sent to a task can optionally perform an action, such as
update, overwrite or increment the task's notification value.  In that way
task notifications can be used to send data to a task, or be used as light
weight and fast binary or counting semaphores.\end{DoxyPre}



\begin{DoxyPre}\hyperlink{task_8h_a4a4bcf98ad282a596e13f3f30582a11b}{vTaskNotifyGiveFromISR()} is intended for use when task notifications are
used as light weight and faster binary or counting semaphore equivalents.
Actual FreeRTOS semaphores are given from an ISR using the
\hyperlink{semphr_8h_a68aa43df8b2a0dbe17d05fad74670ef0}{xSemaphoreGiveFromISR()} API function, the equivalent action that instead uses
a task notification is \hyperlink{task_8h_a4a4bcf98ad282a596e13f3f30582a11b}{vTaskNotifyGiveFromISR()}.\end{DoxyPre}



\begin{DoxyPre}When task notifications are being used as a binary or counting semaphore
equivalent then the task being notified should wait for the notification
using the ulTaskNotificationTake() API function rather than the
\hyperlink{task_8h_a0475fcda9718f403521c270a7270ff93}{xTaskNotifyWait()} API function.\end{DoxyPre}



\begin{DoxyPre}See \href{http://www.FreeRTOS.org/RTOS-task-notifications.html}{\tt http://www.FreeRTOS.org/RTOS-task-notifications.html} for more details.\end{DoxyPre}



\begin{DoxyPre}
\begin{DoxyParams}{Parameters}
{\em xTaskToNotify} & The handle of the task being notified.  The handle to a
task can be returned from the xTaskCreate() API function used to create the
task, and the handle of the currently running task can be obtained by calling
\hyperlink{task_8h_a85a0f9c9f817b18686efbf8f37c72dfc}{xTaskGetCurrentTaskHandle()}.\\
\hline
{\em pxHigherPriorityTaskWoken} & \hyperlink{task_8h_a4a4bcf98ad282a596e13f3f30582a11b}{vTaskNotifyGiveFromISR()} will set
*pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the
task to which the notification was sent to leave the Blocked state, and the
unblocked task has a priority higher than the currently running task.  If
\hyperlink{task_8h_a4a4bcf98ad282a596e13f3f30582a11b}{vTaskNotifyGiveFromISR()} sets this value to pdTRUE then a context switch
should be requested before the interrupt is exited.  How a context switch is
requested from an ISR is dependent on the port - see the documentation page
for the port in use.
\\
\hline
\end{DoxyParams}
\end{DoxyPre}
